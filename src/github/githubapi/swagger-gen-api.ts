// tslint:disable
/**
 * GitHub
 * Powerful collaboration, code review, and code management for open source and private projects. 
 *
 * OpenAPI spec version: v3
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
// import Promise = require('bluebird');

// import Promise = require('bluebird');

let defaultBasePath = 'https://api.github.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {

      if ((data['documentation_url'] && data['message'])) {
        return data;
      }

        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* A user or organization
*/
export class Actor {
    'avatarUrl'?: string;
    'bio'?: string;
    /**
    * The website URL from the profile page
    */
    'blog'?: string;
    'collaborators'?: number;
    'company'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'diskUsage'?: number;
    /**
    * Note: The returned email is the userâ€™s publicly visible email address (or null if the user has not specified a public email address in their profile).
    */
    'email'?: string;
    'followers'?: number;
    'followersUrl'?: string;
    'following'?: number;
    'followingUrl'?: string;
    'gistsUrl'?: string;
    'gravatarId'?: string;
    'hireable'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'location'?: string;
    /**
    * The account username
    */
    'login'?: string;
    /**
    * The full account name
    */
    'name'?: string;
    'organizationsUrl'?: string;
    'ownedPrivateRepos'?: number;
    'plan'?: ActorPlan;
    'privateGists'?: number;
    'publicGists'?: number;
    'publicRepos'?: number;
    'starredUrl'?: string;
    'subscriptionsUrl'?: string;
    'totalPrivateRepos'?: number;
    'type'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "bio",
            "baseName": "bio",
            "type": "string"
        },
        {
            "name": "blog",
            "baseName": "blog",
            "type": "string"
        },
        {
            "name": "collaborators",
            "baseName": "collaborators",
            "type": "number"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "diskUsage",
            "baseName": "disk_usage",
            "type": "number"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "followers",
            "baseName": "followers",
            "type": "number"
        },
        {
            "name": "followersUrl",
            "baseName": "followers_url",
            "type": "string"
        },
        {
            "name": "following",
            "baseName": "following",
            "type": "number"
        },
        {
            "name": "followingUrl",
            "baseName": "following_url",
            "type": "string"
        },
        {
            "name": "gistsUrl",
            "baseName": "gists_url",
            "type": "string"
        },
        {
            "name": "gravatarId",
            "baseName": "gravatar_id",
            "type": "string"
        },
        {
            "name": "hireable",
            "baseName": "hireable",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organizationsUrl",
            "baseName": "organizations_url",
            "type": "string"
        },
        {
            "name": "ownedPrivateRepos",
            "baseName": "owned_private_repos",
            "type": "number"
        },
        {
            "name": "plan",
            "baseName": "plan",
            "type": "ActorPlan"
        },
        {
            "name": "privateGists",
            "baseName": "private_gists",
            "type": "number"
        },
        {
            "name": "publicGists",
            "baseName": "public_gists",
            "type": "number"
        },
        {
            "name": "publicRepos",
            "baseName": "public_repos",
            "type": "number"
        },
        {
            "name": "starredUrl",
            "baseName": "starred_url",
            "type": "string"
        },
        {
            "name": "subscriptionsUrl",
            "baseName": "subscriptions_url",
            "type": "string"
        },
        {
            "name": "totalPrivateRepos",
            "baseName": "total_private_repos",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Actor.attributeTypeMap;
    }
}

export class ActorPlan {
    'collaborators'?: number;
    'name'?: string;
    'privateRepos'?: number;
    'space'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "collaborators",
            "baseName": "collaborators",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "privateRepos",
            "baseName": "private_repos",
            "type": "number"
        },
        {
            "name": "space",
            "baseName": "space",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActorPlan.attributeTypeMap;
    }
}

export class Asset {
    'contentType'?: string;
    'createdAt'?: string;
    'downloadCount'?: number;
    'id'?: number;
    'label'?: string;
    'name'?: string;
    'size'?: number;
    'state'?: string;
    'updatedAt'?: string;
    'uploader'?: User;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "downloadCount",
            "baseName": "download_count",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "uploader",
            "baseName": "uploader",
            "type": "User"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Asset.attributeTypeMap;
    }
}

export class AssetPatch {
    'label'?: string;
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AssetPatch.attributeTypeMap;
    }
}

export class Assets extends Array<Asset> {

    static discriminator: string | undefined = undefined;

}

export class Assignees extends Array<User> {

    static discriminator: string | undefined = undefined;

}

export class Blob {
    'content'?: string;
    'encoding'?: string;
    'sha'?: string;
    'size'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Blob.attributeTypeMap;
    }
}

export class Blobs {
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Blobs.attributeTypeMap;
    }
}

export class Branch {
    'links'?: BranchLinks;
    'commit'?: BranchCommit;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "BranchLinks"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "BranchCommit"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Branch.attributeTypeMap;
    }
}

export class BranchCommit {
    'author'?: User;
    'commit'?: BranchCommitCommit;
    'committer'?: User;
    'parents'?: Array<BranchCommitCommitTree>;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "BranchCommitCommit"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "User"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<BranchCommitCommitTree>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchCommit.attributeTypeMap;
    }
}

export class BranchCommitCommit {
    'author'?: BranchCommitCommitAuthor;
    'committer'?: BranchCommitCommitAuthor;
    'message'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "BranchCommitCommitAuthor"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "BranchCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchCommitCommit.attributeTypeMap;
    }
}

export class BranchCommitCommitAuthor {
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'date'?: string;
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchCommitCommitAuthor.attributeTypeMap;
    }
}

export class BranchCommitCommitTree {
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchCommitCommitTree.attributeTypeMap;
    }
}

export class BranchLinks {
    'html'?: string;
    'self'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchLinks.attributeTypeMap;
    }
}

export class Branches extends Array<BranchesInner> {

    static discriminator: string | undefined = undefined;

}

export class BranchesInner {
    'commit'?: BranchCommitCommitTree;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchesInner.attributeTypeMap;
    }
}

export class CodeFrequencyStats extends Array<number> {

    static discriminator: string | undefined = undefined;

}

export class Comment {
    'body'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Comment.attributeTypeMap;
    }
}

export class CommentBody {
    'body': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommentBody.attributeTypeMap;
    }
}

export class Comments extends Array<CommentsInner> {

    static discriminator: string | undefined = undefined;

}

export class CommentsInner {
    'body'?: string;
    /**
    * ISO 8601.
    */
    'createdAt'?: string;
    'id'?: number;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return CommentsInner.attributeTypeMap;
    }
}

export class Commit {
    'author'?: User;
    'commit'?: BranchCommitCommit;
    'committer'?: User;
    'files'?: Array<CommitFiles>;
    'parents'?: Array<BranchCommitCommitTree>;
    'sha'?: string;
    'stats'?: CommitStats;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "BranchCommitCommit"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "User"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "Array<CommitFiles>"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<BranchCommitCommitTree>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "stats",
            "baseName": "stats",
            "type": "CommitStats"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Commit.attributeTypeMap;
    }
}

export class CommitActivityStats extends Array<CommitActivityStatsInner> {

    static discriminator: string | undefined = undefined;

}

export class CommitActivityStatsInner {
    'days'?: Array<number>;
    'total'?: number;
    'week'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "days",
            "baseName": "days",
            "type": "Array<number>"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "week",
            "baseName": "week",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CommitActivityStatsInner.attributeTypeMap;
    }
}

export class CommitComment {
    'body'?: string;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'line'?: number;
    'path'?: string;
    'position'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "line",
            "baseName": "line",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return CommitComment.attributeTypeMap;
    }
}

export class CommitCommentBody {
    'body': string;
    /**
    * Deprecated - Use position parameter instead.
    */
    'line'?: string;
    /**
    * Line number in the file to comment on. Defaults to null.
    */
    'number'?: string;
    /**
    * Relative path of the file to comment on.
    */
    'path'?: string;
    /**
    * Line index in the diff to comment on.
    */
    'position'?: number;
    /**
    * SHA of the commit to comment on.
    */
    'sha': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "line",
            "baseName": "line",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitCommentBody.attributeTypeMap;
    }
}

export class CommitFiles {
    'additions'?: number;
    'blobUrl'?: string;
    'changes'?: number;
    'deletions'?: number;
    'filename'?: string;
    'patch'?: string;
    'rawUrl'?: string;
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additions",
            "baseName": "additions",
            "type": "number"
        },
        {
            "name": "blobUrl",
            "baseName": "blob_url",
            "type": "string"
        },
        {
            "name": "changes",
            "baseName": "changes",
            "type": "number"
        },
        {
            "name": "deletions",
            "baseName": "deletions",
            "type": "number"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "string"
        },
        {
            "name": "rawUrl",
            "baseName": "raw_url",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommitFiles.attributeTypeMap;
    }
}

export class CommitStats {
    'additions'?: number;
    'deletions'?: number;
    'total'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additions",
            "baseName": "additions",
            "type": "number"
        },
        {
            "name": "deletions",
            "baseName": "deletions",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CommitStats.attributeTypeMap;
    }
}

export class Commits extends Array<BranchCommit> {

    static discriminator: string | undefined = undefined;

}

export class CompareCommits {
    'aheadBy'?: number;
    'baseCommit'?: ComparecommitsBaseCommit;
    'behindBy'?: number;
    'commits'?: Array<ComparecommitsBaseCommit>;
    'diffUrl'?: string;
    'files'?: Array<ComparecommitsFiles>;
    'htmlUrl'?: string;
    'patchUrl'?: string;
    'permalinkUrl'?: string;
    'status'?: string;
    'totalCommits'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aheadBy",
            "baseName": "ahead_by",
            "type": "number"
        },
        {
            "name": "baseCommit",
            "baseName": "base_commit",
            "type": "ComparecommitsBaseCommit"
        },
        {
            "name": "behindBy",
            "baseName": "behind_by",
            "type": "number"
        },
        {
            "name": "commits",
            "baseName": "commits",
            "type": "Array<ComparecommitsBaseCommit>"
        },
        {
            "name": "diffUrl",
            "baseName": "diff_url",
            "type": "string"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "Array<ComparecommitsFiles>"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "patchUrl",
            "baseName": "patch_url",
            "type": "string"
        },
        {
            "name": "permalinkUrl",
            "baseName": "permalink_url",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "totalCommits",
            "baseName": "total_commits",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CompareCommits.attributeTypeMap;
    }
}

export class ComparecommitsBaseCommit {
    'author'?: User;
    'commit'?: ComparecommitsBaseCommitCommit;
    'committer'?: User;
    'parents'?: Array<BranchCommitCommitTree>;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "ComparecommitsBaseCommitCommit"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "User"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<BranchCommitCommitTree>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ComparecommitsBaseCommit.attributeTypeMap;
    }
}

export class ComparecommitsBaseCommitCommit {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'committer'?: ComparecommitsBaseCommitCommitAuthor;
    'message'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ComparecommitsBaseCommitCommit.attributeTypeMap;
    }
}

export class ComparecommitsBaseCommitCommitAuthor {
    'date'?: string;
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ComparecommitsBaseCommitCommitAuthor.attributeTypeMap;
    }
}

export class ComparecommitsFiles {
    'additions'?: number;
    'blobUrl'?: string;
    'changes'?: number;
    'contentsUrl'?: string;
    'deletions'?: number;
    'filename'?: string;
    'patch'?: string;
    'rawUrl'?: string;
    'sha'?: string;
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additions",
            "baseName": "additions",
            "type": "number"
        },
        {
            "name": "blobUrl",
            "baseName": "blob_url",
            "type": "string"
        },
        {
            "name": "changes",
            "baseName": "changes",
            "type": "number"
        },
        {
            "name": "contentsUrl",
            "baseName": "contents_url",
            "type": "string"
        },
        {
            "name": "deletions",
            "baseName": "deletions",
            "type": "number"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "patch",
            "baseName": "patch",
            "type": "string"
        },
        {
            "name": "rawUrl",
            "baseName": "raw_url",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ComparecommitsFiles.attributeTypeMap;
    }
}

export class ContentsPath {
    'links'?: ContentspathLinks;
    'content'?: string;
    'encoding'?: string;
    'gitUrl'?: string;
    'htmlUrl'?: string;
    'name'?: string;
    'path'?: string;
    'sha'?: string;
    'size'?: number;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ContentspathLinks"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        },
        {
            "name": "gitUrl",
            "baseName": "git_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContentsPath.attributeTypeMap;
    }
}

export class ContentspathLinks {
    'git'?: string;
    'html'?: string;
    'self'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "git",
            "baseName": "git",
            "type": "string"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "string"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContentspathLinks.attributeTypeMap;
    }
}

export class ContributorsStats extends Array<ContributorsStatsInner> {

    static discriminator: string | undefined = undefined;

}

export class ContributorsStatsInner {
    'author'?: ContributorsStatsInnerAuthor;
    /**
    * The Total number of commits authored by the contributor.
    */
    'total'?: number;
    'weeks'?: Array<ContributorsStatsInnerWeeks>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ContributorsStatsInnerAuthor"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "weeks",
            "baseName": "weeks",
            "type": "Array<ContributorsStatsInnerWeeks>"
        }    ];

    static getAttributeTypeMap() {
        return ContributorsStatsInner.attributeTypeMap;
    }
}

export class ContributorsStatsInnerAuthor {
    'avatarUrl'?: string;
    'gravatarId'?: string;
    'id'?: number;
    'login'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "gravatarId",
            "baseName": "gravatar_id",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContributorsStatsInnerAuthor.attributeTypeMap;
    }
}

export class ContributorsStatsInnerWeeks {
    /**
    * Number of additions.
    */
    'a'?: number;
    /**
    * Number of commits.
    */
    'c'?: number;
    /**
    * Number of deletions.
    */
    'd'?: number;
    /**
    * Start of the week.
    */
    'w'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "a",
            "baseName": "a",
            "type": "number"
        },
        {
            "name": "c",
            "baseName": "c",
            "type": "number"
        },
        {
            "name": "d",
            "baseName": "d",
            "type": "number"
        },
        {
            "name": "w",
            "baseName": "w",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContributorsStatsInnerWeeks.attributeTypeMap;
    }
}

export class CreateFile {
    'commit'?: CreateFileCommit;
    'content'?: CreateFileContent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "CreateFileCommit"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "CreateFileContent"
        }    ];

    static getAttributeTypeMap() {
        return CreateFile.attributeTypeMap;
    }
}

export class CreateFileBody {
    'committer'?: CreateFileBodyCommitter;
    'content'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "committer",
            "baseName": "committer",
            "type": "CreateFileBodyCommitter"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileBody.attributeTypeMap;
    }
}

export class CreateFileBodyCommitter {
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileBodyCommitter.attributeTypeMap;
    }
}

export class CreateFileCommit {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'committer'?: ComparecommitsBaseCommitCommitAuthor;
    'htmlUrl'?: string;
    'message'?: string;
    'parents'?: Array<CreateFileCommitParents>;
    'sha'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<CreateFileCommitParents>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileCommit.attributeTypeMap;
    }
}

export class CreateFileCommitParents {
    'htmlUrl'?: string;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileCommitParents.attributeTypeMap;
    }
}

export class CreateFileContent {
    'links'?: ContentspathLinks;
    'gitUrl'?: string;
    'htmlUrl'?: string;
    'name'?: string;
    'path'?: string;
    'sha'?: string;
    'size'?: number;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ContentspathLinks"
        },
        {
            "name": "gitUrl",
            "baseName": "git_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFileContent.attributeTypeMap;
    }
}

export class DeleteFile {
    'commit'?: DeleteFileCommit;
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commit",
            "baseName": "commit",
            "type": "DeleteFileCommit"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFile.attributeTypeMap;
    }
}

export class DeleteFileBody {
    'committer'?: CreateFileBodyCommitter;
    'message'?: string;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "committer",
            "baseName": "committer",
            "type": "CreateFileBodyCommitter"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFileBody.attributeTypeMap;
    }
}

export class DeleteFileCommit {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'committer'?: ComparecommitsBaseCommitCommitAuthor;
    'htmlUrl'?: string;
    'message'?: string;
    'parents'?: CreateFileCommitParents;
    'sha'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "CreateFileCommitParents"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeleteFileCommit.attributeTypeMap;
    }
}

export class Deployment {
    'description'?: string;
    'payload'?: DeploymentPayload;
    'ref'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "DeploymentPayload"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Deployment.attributeTypeMap;
    }
}

export class DeploymentPayload {
    'deployUser'?: string;
    'environment'?: string;
    'roomId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deployUser",
            "baseName": "deploy_user",
            "type": "string"
        },
        {
            "name": "environment",
            "baseName": "environment",
            "type": "string"
        },
        {
            "name": "roomId",
            "baseName": "room_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DeploymentPayload.attributeTypeMap;
    }
}

export class DeploymentResp {
    'createdAt'?: string;
    'creator'?: User;
    'description'?: string;
    'id'?: number;
    'payload'?: string;
    'sha'?: string;
    'statusesUrl'?: string;
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "statusesUrl",
            "baseName": "statuses_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeploymentResp.attributeTypeMap;
    }
}

export class DeploymentStatuses extends Array<DeploymentstatusesInner> {

    static discriminator: string | undefined = undefined;

}

export class DeploymentStatusesCreate {
    'description'?: string;
    'state'?: string;
    'targetUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeploymentStatusesCreate.attributeTypeMap;
    }
}

export class DeploymentstatusesInner {
    'createdAt'?: string;
    'creator'?: User;
    'description'?: string;
    'id'?: number;
    'payload'?: string;
    'state'?: string;
    'targetUrl'?: string;
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeploymentstatusesInner.attributeTypeMap;
    }
}

export class Download {
    'contentType'?: string;
    'description'?: string;
    'downloadCount'?: number;
    'htmlUrl'?: string;
    'id'?: number;
    'name'?: string;
    'size'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "downloadCount",
            "baseName": "download_count",
            "type": "number"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Download.attributeTypeMap;
    }
}

export class Downloads extends Array<Download> {

    static discriminator: string | undefined = undefined;

}

export class EditTeam {
    'name': string;
    'permission'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EditTeam.attributeTypeMap;
    }
}

export class EmailsPost extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class Emojis extends null<String, string> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Emojis.attributeTypeMap);
    }
}

export class Event {
    'actor'?: Actor;
    'createdAt'?: any;
    'id'?: number;
    'org'?: Organization;
    'payload'?: any;
    '_public'?: boolean;
    'repo'?: EventRepo;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actor",
            "baseName": "actor",
            "type": "Actor"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "any"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "org",
            "baseName": "org",
            "type": "Organization"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "any"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "repo",
            "baseName": "repo",
            "type": "EventRepo"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Event.attributeTypeMap;
    }
}

export class EventRepo {
    'id'?: number;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventRepo.attributeTypeMap;
    }
}

export class Events extends Array<Event> {

    static discriminator: string | undefined = undefined;

}

export class Feeds {
    'links'?: FeedsLinks;
    'currentUserActorUrl'?: string;
    'currentUserOrganizationUrl'?: string;
    'currentUserPublic'?: string;
    'currentUserUrl'?: string;
    'timelineUrl'?: string;
    'userUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "FeedsLinks"
        },
        {
            "name": "currentUserActorUrl",
            "baseName": "current_user_actor_url",
            "type": "string"
        },
        {
            "name": "currentUserOrganizationUrl",
            "baseName": "current_user_organization_url",
            "type": "string"
        },
        {
            "name": "currentUserPublic",
            "baseName": "current_user_public",
            "type": "string"
        },
        {
            "name": "currentUserUrl",
            "baseName": "current_user_url",
            "type": "string"
        },
        {
            "name": "timelineUrl",
            "baseName": "timeline_url",
            "type": "string"
        },
        {
            "name": "userUrl",
            "baseName": "user_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Feeds.attributeTypeMap;
    }
}

export class FeedsLinks {
    'currentUser'?: FeedsLinksCurrentUser;
    'currentUserActor'?: FeedsLinksCurrentUser;
    'currentUserOrganization'?: FeedsLinksCurrentUser;
    'currentUserPublic'?: FeedsLinksCurrentUser;
    'timeline'?: FeedsLinksCurrentUser;
    'user'?: FeedsLinksCurrentUser;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentUser",
            "baseName": "current_user",
            "type": "FeedsLinksCurrentUser"
        },
        {
            "name": "currentUserActor",
            "baseName": "current_user_actor",
            "type": "FeedsLinksCurrentUser"
        },
        {
            "name": "currentUserOrganization",
            "baseName": "current_user_organization",
            "type": "FeedsLinksCurrentUser"
        },
        {
            "name": "currentUserPublic",
            "baseName": "current_user_public",
            "type": "FeedsLinksCurrentUser"
        },
        {
            "name": "timeline",
            "baseName": "timeline",
            "type": "FeedsLinksCurrentUser"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "FeedsLinksCurrentUser"
        }    ];

    static getAttributeTypeMap() {
        return FeedsLinks.attributeTypeMap;
    }
}

export class FeedsLinksCurrentUser {
    'href'?: string;
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeedsLinksCurrentUser.attributeTypeMap;
    }
}

export class ForkBody {
    'organization'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ForkBody.attributeTypeMap;
    }
}

export class Forks {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return Forks.attributeTypeMap;
    }
}

export class Gist {
    'comments'?: number;
    'commentsUrl'?: string;
    /**
    * Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
    */
    'createdAt'?: string;
    'description'?: string;
    'files'?: GistFiles;
    'forks'?: Array<GistForks>;
    'gitPullUrl'?: string;
    'gitPushUrl'?: string;
    'history'?: Array<GistHistory>;
    'htmlUrl'?: string;
    'id'?: string;
    '_public'?: boolean;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "commentsUrl",
            "baseName": "comments_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "GistFiles"
        },
        {
            "name": "forks",
            "baseName": "forks",
            "type": "Array<GistForks>"
        },
        {
            "name": "gitPullUrl",
            "baseName": "git_pull_url",
            "type": "string"
        },
        {
            "name": "gitPushUrl",
            "baseName": "git_push_url",
            "type": "string"
        },
        {
            "name": "history",
            "baseName": "history",
            "type": "Array<GistHistory>"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return Gist.attributeTypeMap;
    }
}

export class GistFiles {
    'ringErl'?: GistFilesRingErl;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ringErl",
            "baseName": "ring.erl",
            "type": "GistFilesRingErl"
        }    ];

    static getAttributeTypeMap() {
        return GistFiles.attributeTypeMap;
    }
}

export class GistFilesRingErl {
    'filename'?: string;
    'rawUrl'?: string;
    'size'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        },
        {
            "name": "rawUrl",
            "baseName": "raw_url",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GistFilesRingErl.attributeTypeMap;
    }
}

export class GistForks {
    /**
    * Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
    */
    'createdAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return GistForks.attributeTypeMap;
    }
}

export class GistHistory {
    'changeStatus'?: CommitStats;
    /**
    * Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
    */
    'committedAt'?: string;
    'url'?: string;
    'user'?: User;
    'version'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "changeStatus",
            "baseName": "change_status",
            "type": "CommitStats"
        },
        {
            "name": "committedAt",
            "baseName": "committed_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GistHistory.attributeTypeMap;
    }
}

export class Gists extends Array<GistsInner> {

    static discriminator: string | undefined = undefined;

}

export class GistsInner {
    'comments'?: number;
    'commentsUrl'?: string;
    'createdAt'?: string;
    'description'?: string;
    'files'?: GistFiles;
    'gitPullUrl'?: string;
    'gitPushUrl'?: string;
    'htmlUrl'?: string;
    'id'?: string;
    '_public'?: boolean;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "commentsUrl",
            "baseName": "comments_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "GistFiles"
        },
        {
            "name": "gitPullUrl",
            "baseName": "git_pull_url",
            "type": "string"
        },
        {
            "name": "gitPushUrl",
            "baseName": "git_push_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return GistsInner.attributeTypeMap;
    }
}

export class GitCommit {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'message'?: string;
    'parents'?: string;
    'tree'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitCommit.attributeTypeMap;
    }
}

export class GitRefPatch {
    'force'?: boolean;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "force",
            "baseName": "force",
            "type": "boolean"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitRefPatch.attributeTypeMap;
    }
}

export class Gitignore extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class GitignoreLang {
    'name'?: string;
    'source'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GitignoreLang.attributeTypeMap;
    }
}

export class HeadBranch {
    'object'?: HeadBranchObject;
    'ref'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "object",
            "baseName": "object",
            "type": "HeadBranchObject"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HeadBranch.attributeTypeMap;
    }
}

export class HeadBranchObject {
    'sha'?: string;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HeadBranchObject.attributeTypeMap;
    }
}

export class Hook extends Array<HookInner> {

    static discriminator: string | undefined = undefined;

}

export class HookBody {
    'active'?: boolean;
    'addEvents'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "addEvents",
            "baseName": "add_events",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return HookBody.attributeTypeMap;
    }
}

export class HookInner {
    'active'?: boolean;
    'config'?: HookInnerConfig;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'events'?: Array<string>;
    'id'?: number;
    'name'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "HookInnerConfig"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "events",
            "baseName": "events",
            "type": "Array<string>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HookInner.attributeTypeMap;
    }
}

export class HookInnerConfig {
    'contentType'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HookInnerConfig.attributeTypeMap;
    }
}

export class Issue {
    'assignee'?: string;
    'body'?: string;
    'labels'?: Array<string>;
    'milestone'?: number;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Issue.attributeTypeMap;
    }
}

export class IssueEvent {
    'actor'?: Actor;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'event'?: string;
    'issue'?: IssueEventIssue;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actor",
            "baseName": "actor",
            "type": "Actor"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "issue",
            "baseName": "issue",
            "type": "IssueEventIssue"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssueEvent.attributeTypeMap;
    }
}

export class IssueEventIssue {
    'assignee'?: User;
    'body'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'closedAt'?: string;
    'comments'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'htmlUrl'?: string;
    'labels'?: Array<IssueEventIssueLabels>;
    'milestone'?: IssueEventIssueMilestone;
    'number'?: number;
    'pullRequest'?: IssueEventIssuePullRequest;
    'state'?: string;
    'title'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assignee",
            "baseName": "assignee",
            "type": "User"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<IssueEventIssueLabels>"
        },
        {
            "name": "milestone",
            "baseName": "milestone",
            "type": "IssueEventIssueMilestone"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "pullRequest",
            "baseName": "pull_request",
            "type": "IssueEventIssuePullRequest"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return IssueEventIssue.attributeTypeMap;
    }
}

export class IssueEventIssueLabels {
    'color'?: string;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssueEventIssueLabels.attributeTypeMap;
    }
}

export class IssueEventIssueMilestone {
    'closedIssues'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'creator'?: User;
    'description'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'dueOn'?: string;
    'number'?: number;
    'openIssues'?: number;
    'state'?: string;
    'title'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "closedIssues",
            "baseName": "closed_issues",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "openIssues",
            "baseName": "open_issues",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssueEventIssueMilestone.attributeTypeMap;
    }
}

export class IssueEventIssuePullRequest {
    'diffUrl'?: string;
    'htmlUrl'?: string;
    'patchUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "diffUrl",
            "baseName": "diff_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "patchUrl",
            "baseName": "patch_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssueEventIssuePullRequest.attributeTypeMap;
    }
}

export class IssueEvents extends Array<IssueEvent> {

    static discriminator: string | undefined = undefined;

}

export class Issues extends Array<IssueEventIssue> {

    static discriminator: string | undefined = undefined;

}

export class IssuesComment {
    'body'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return IssuesComment.attributeTypeMap;
    }
}

export class IssuesComments extends Array<IssuesCommentsInner> {

    static discriminator: string | undefined = undefined;

}

export class IssuesCommentsInner {
    'links'?: IssuesCommentsInnerLinks;
    'body'?: string;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'id'?: number;
    'path'?: string;
    'position'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "IssuesCommentsInnerLinks"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return IssuesCommentsInner.attributeTypeMap;
    }
}

export class IssuesCommentsInnerLinks {
    'html'?: IssuesCommentsInnerLinksHtml;
    'pullRequest'?: IssuesCommentsInnerLinksHtml;
    'self'?: IssuesCommentsInnerLinksHtml;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "html",
            "baseName": "html",
            "type": "IssuesCommentsInnerLinksHtml"
        },
        {
            "name": "pullRequest",
            "baseName": "pull_request",
            "type": "IssuesCommentsInnerLinksHtml"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "IssuesCommentsInnerLinksHtml"
        }    ];

    static getAttributeTypeMap() {
        return IssuesCommentsInnerLinks.attributeTypeMap;
    }
}

export class IssuesCommentsInnerLinksHtml {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IssuesCommentsInnerLinksHtml.attributeTypeMap;
    }
}

export class Keys extends Array<KeysInner> {

    static discriminator: string | undefined = undefined;

}

export class KeysInner {
    'id'?: number;
    'key'?: string;
    'title'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return KeysInner.attributeTypeMap;
    }
}

export class Label {
    'color'?: string;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Label.attributeTypeMap;
    }
}

export class Labels extends Array<LabelsInner> {

    static discriminator: string | undefined = undefined;

}

export class LabelsInner {
    'color'?: string;
    'name'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LabelsInner.attributeTypeMap;
    }
}

export class Languages extends null<String, number> {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Languages.attributeTypeMap);
    }
}

export class Markdown {
    'context'?: string;
    'mode'?: string;
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Markdown.attributeTypeMap;
    }
}

export class Merge {
    'merged'?: boolean;
    'message'?: string;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merged",
            "baseName": "merged",
            "type": "boolean"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Merge.attributeTypeMap;
    }
}

export class MergePullBody {
    'commitMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commitMessage",
            "baseName": "commit_message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergePullBody.attributeTypeMap;
    }
}

export class MergesBody {
    'base'?: string;
    'commitMessage'?: string;
    'head'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base",
            "baseName": "base",
            "type": "string"
        },
        {
            "name": "commitMessage",
            "baseName": "commit_message",
            "type": "string"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergesBody.attributeTypeMap;
    }
}

export class MergesConflict {
    /**
    * Error message
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergesConflict.attributeTypeMap;
    }
}

export class MergesSuccessful {
    'author'?: User;
    'commentsUrl'?: string;
    'commit'?: MergesSuccessfulCommit;
    'committer'?: User;
    'merged'?: boolean;
    'message'?: string;
    'parents'?: Array<BranchCommitCommitTree>;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "commentsUrl",
            "baseName": "comments_url",
            "type": "string"
        },
        {
            "name": "commit",
            "baseName": "commit",
            "type": "MergesSuccessfulCommit"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "User"
        },
        {
            "name": "merged",
            "baseName": "merged",
            "type": "boolean"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<BranchCommitCommitTree>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergesSuccessful.attributeTypeMap;
    }
}

export class MergesSuccessfulCommit {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'commentCount'?: number;
    'committer'?: ComparecommitsBaseCommitCommitAuthor;
    'message'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "commentCount",
            "baseName": "comment_count",
            "type": "number"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MergesSuccessfulCommit.attributeTypeMap;
    }
}

export class Meta {
    'git'?: Array<string>;
    'hooks'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "git",
            "baseName": "git",
            "type": "Array<string>"
        },
        {
            "name": "hooks",
            "baseName": "hooks",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Meta.attributeTypeMap;
    }
}

export class Milestone {
    'closedIssues'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'creator'?: User;
    'description'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'dueOn'?: string;
    'number'?: number;
    'openIssues'?: number;
    'state'?: string;
    'title'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "closedIssues",
            "baseName": "closed_issues",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "openIssues",
            "baseName": "open_issues",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Milestone.attributeTypeMap;
    }
}

export class MilestoneUpdate {
    'description'?: string;
    'dueOn'?: string;
    'state'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueOn",
            "baseName": "due_on",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MilestoneUpdate.attributeTypeMap;
    }
}

export class NotificationMarkRead {
    'lastReadAt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastReadAt",
            "baseName": "last_read_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationMarkRead.attributeTypeMap;
    }
}

export class Notifications {
    'id'?: number;
    'lastReadAt'?: string;
    'reason'?: string;
    'repository'?: NotificationsRepository;
    'subject'?: NotificationsSubject;
    'unread'?: boolean;
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "lastReadAt",
            "baseName": "last_read_at",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "NotificationsRepository"
        },
        {
            "name": "subject",
            "baseName": "subject",
            "type": "NotificationsSubject"
        },
        {
            "name": "unread",
            "baseName": "unread",
            "type": "boolean"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Notifications.attributeTypeMap;
    }
}

export class NotificationsRepository {
    'description'?: string;
    'fork'?: boolean;
    'fullName'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'name'?: string;
    'owner'?: Actor;
    '_private'?: boolean;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fork",
            "baseName": "fork",
            "type": "boolean"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "Actor"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationsRepository.attributeTypeMap;
    }
}

export class NotificationsSubject {
    'latestCommentUrl'?: string;
    'title'?: string;
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latestCommentUrl",
            "baseName": "latest_comment_url",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NotificationsSubject.attributeTypeMap;
    }
}

export class OrgTeamsPost {
    'name': string;
    'permission'?: string;
    'repoNames'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        },
        {
            "name": "repoNames",
            "baseName": "repo_names",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return OrgTeamsPost.attributeTypeMap;
    }
}

export class Organization extends Actor {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Organization.attributeTypeMap);
    }
}

export class OrganizationAsTeamMember {
    'errors'?: Array<OrganizationAsTeamMemberErrors>;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<OrganizationAsTeamMemberErrors>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationAsTeamMember.attributeTypeMap;
    }
}

export class OrganizationAsTeamMemberErrors {
    'code'?: string;
    'field'?: string;
    'resource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationAsTeamMemberErrors.attributeTypeMap;
    }
}

export class ParticipationStats {
    'all'?: Array<number>;
    'owner'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "all",
            "baseName": "all",
            "type": "Array<number>"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return ParticipationStats.attributeTypeMap;
    }
}

export class PatchGist {
    'description'?: string;
    'files'?: PatchGistFiles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "PatchGistFiles"
        }    ];

    static getAttributeTypeMap() {
        return PatchGist.attributeTypeMap;
    }
}

export class PatchGistFiles {
    'deleteThisFileTxt'?: string;
    'file1Txt'?: PatchGistFilesFile1Txt;
    'newFileTxt'?: PatchGistFilesFile1Txt;
    'oldNameTxt'?: PatchGistFilesOldNameTxt;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deleteThisFileTxt",
            "baseName": "delete_this_file.txt",
            "type": "string"
        },
        {
            "name": "file1Txt",
            "baseName": "file1.txt",
            "type": "PatchGistFilesFile1Txt"
        },
        {
            "name": "newFileTxt",
            "baseName": "new_file.txt",
            "type": "PatchGistFilesFile1Txt"
        },
        {
            "name": "oldNameTxt",
            "baseName": "old_name.txt",
            "type": "PatchGistFilesOldNameTxt"
        }    ];

    static getAttributeTypeMap() {
        return PatchGistFiles.attributeTypeMap;
    }
}

export class PatchGistFilesFile1Txt {
    'content'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PatchGistFilesFile1Txt.attributeTypeMap;
    }
}

export class PatchGistFilesOldNameTxt {
    'content'?: string;
    'filename'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "filename",
            "baseName": "filename",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PatchGistFilesOldNameTxt.attributeTypeMap;
    }
}

export class PatchOrg {
    /**
    * Billing email address. This address is not publicized.
    */
    'billingEmail'?: string;
    'company'?: string;
    /**
    * Publicly visible email address.
    */
    'email'?: string;
    'location'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingEmail",
            "baseName": "billing_email",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PatchOrg.attributeTypeMap;
    }
}

export class PostGist {
    'description'?: string;
    'files'?: PostGistFiles;
    '_public'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "PostGistFiles"
        },
        {
            "name": "_public",
            "baseName": "public",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PostGist.attributeTypeMap;
    }
}

export class PostGistFiles {
    'file1Txt'?: PatchGistFilesFile1Txt;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "file1Txt",
            "baseName": "file1.txt",
            "type": "PatchGistFilesFile1Txt"
        }    ];

    static getAttributeTypeMap() {
        return PostGistFiles.attributeTypeMap;
    }
}

export class PostRepo {
    /**
    * True to create an initial commit with empty README. Default is false.
    */
    'autoInit'?: boolean;
    'description'?: string;
    /**
    * Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, \"Haskell\" Ignored if auto_init parameter is not provided. 
    */
    'gitignoreTemplate'?: string;
    /**
    * True to enable downloads for this repository, false to disable them. Default is true.
    */
    'hasDownloads'?: boolean;
    /**
    * True to enable issues for this repository, false to disable them. Default is true.
    */
    'hasIssues'?: boolean;
    /**
    * True to enable the wiki for this repository, false to disable it. Default is true.
    */
    'hasWiki'?: boolean;
    'homepage'?: string;
    'name': string;
    /**
    * True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account.
    */
    '_private'?: boolean;
    /**
    * The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization.
    */
    'teamId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoInit",
            "baseName": "auto_init",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "gitignoreTemplate",
            "baseName": "gitignore_template",
            "type": "string"
        },
        {
            "name": "hasDownloads",
            "baseName": "has_downloads",
            "type": "boolean"
        },
        {
            "name": "hasIssues",
            "baseName": "has_issues",
            "type": "boolean"
        },
        {
            "name": "hasWiki",
            "baseName": "has_wiki",
            "type": "boolean"
        },
        {
            "name": "homepage",
            "baseName": "homepage",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "teamId",
            "baseName": "team_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostRepo.attributeTypeMap;
    }
}

export class PullRequest {
    'links'?: PullRequestLinks;
    'additions'?: number;
    'base'?: PullRequestBase;
    'body'?: string;
    'changedFiles'?: number;
    'closedAt'?: string;
    'comments'?: number;
    'commits'?: number;
    'createdAt'?: string;
    'deletions'?: number;
    'diffUrl'?: string;
    'head'?: PullRequestBase;
    'htmlUrl'?: string;
    'issueUrl'?: string;
    'mergeCommitSha'?: string;
    'mergeable'?: boolean;
    'merged'?: boolean;
    'mergedAt'?: string;
    'mergedBy'?: ContributorsStatsInnerAuthor;
    'number'?: number;
    'patchUrl'?: string;
    'state'?: string;
    'title'?: string;
    'updatedAt'?: string;
    'url'?: string;
    'user'?: ContributorsStatsInnerAuthor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PullRequestLinks"
        },
        {
            "name": "additions",
            "baseName": "additions",
            "type": "number"
        },
        {
            "name": "base",
            "baseName": "base",
            "type": "PullRequestBase"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "changedFiles",
            "baseName": "changed_files",
            "type": "number"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "commits",
            "baseName": "commits",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "deletions",
            "baseName": "deletions",
            "type": "number"
        },
        {
            "name": "diffUrl",
            "baseName": "diff_url",
            "type": "string"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "PullRequestBase"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "issueUrl",
            "baseName": "issue_url",
            "type": "string"
        },
        {
            "name": "mergeCommitSha",
            "baseName": "merge_commit_sha",
            "type": "string"
        },
        {
            "name": "mergeable",
            "baseName": "mergeable",
            "type": "boolean"
        },
        {
            "name": "merged",
            "baseName": "merged",
            "type": "boolean"
        },
        {
            "name": "mergedAt",
            "baseName": "merged_at",
            "type": "string"
        },
        {
            "name": "mergedBy",
            "baseName": "merged_by",
            "type": "ContributorsStatsInnerAuthor"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "patchUrl",
            "baseName": "patch_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ContributorsStatsInnerAuthor"
        }    ];

    static getAttributeTypeMap() {
        return PullRequest.attributeTypeMap;
    }
}

export class PullRequestBase {
    'label'?: string;
    'ref'?: string;
    'repo'?: Repo;
    'sha'?: string;
    'user'?: ContributorsStatsInnerAuthor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "repo",
            "baseName": "repo",
            "type": "Repo"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ContributorsStatsInnerAuthor"
        }    ];

    static getAttributeTypeMap() {
        return PullRequestBase.attributeTypeMap;
    }
}

export class PullRequestLinks {
    'comments'?: IssuesCommentsInnerLinksHtml;
    'html'?: IssuesCommentsInnerLinksHtml;
    'reviewComments'?: IssuesCommentsInnerLinksHtml;
    'self'?: IssuesCommentsInnerLinksHtml;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "IssuesCommentsInnerLinksHtml"
        },
        {
            "name": "html",
            "baseName": "html",
            "type": "IssuesCommentsInnerLinksHtml"
        },
        {
            "name": "reviewComments",
            "baseName": "review_comments",
            "type": "IssuesCommentsInnerLinksHtml"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "IssuesCommentsInnerLinksHtml"
        }    ];

    static getAttributeTypeMap() {
        return PullRequestLinks.attributeTypeMap;
    }
}

export class PullUpdate {
    'body'?: string;
    'state'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PullUpdate.attributeTypeMap;
    }
}

export class Pulls extends Array<PullsInner> {

    static discriminator: string | undefined = undefined;

}

export class PullsComment {
    'links'?: IssuesCommentsInnerLinks;
    'body'?: string;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'id'?: number;
    'path'?: string;
    'position'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: ContributorsStatsInnerAuthor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "IssuesCommentsInnerLinks"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ContributorsStatsInnerAuthor"
        }    ];

    static getAttributeTypeMap() {
        return PullsComment.attributeTypeMap;
    }
}

export class PullsCommentPost {
    'body'?: string;
    'commitId'?: string;
    'path'?: string;
    'position'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PullsCommentPost.attributeTypeMap;
    }
}

export class PullsComments extends Array<PullsCommentsInner> {

    static discriminator: string | undefined = undefined;

}

export class PullsCommentsInner {
    'links'?: IssuesCommentsInnerLinks;
    'body'?: string;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'id'?: number;
    'path'?: string;
    'position'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: ContributorsStatsInnerAuthor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "IssuesCommentsInnerLinks"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ContributorsStatsInnerAuthor"
        }    ];

    static getAttributeTypeMap() {
        return PullsCommentsInner.attributeTypeMap;
    }
}

export class PullsInner {
    'links'?: PullRequestLinks;
    'base'?: PullRequestBase;
    'body'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'closedAt'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'diffUrl'?: string;
    'head'?: PullRequestBase;
    'htmlUrl'?: string;
    'issueUrl'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'mergedAt'?: string;
    'number'?: number;
    'patchUrl'?: string;
    'state'?: string;
    'title'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: ContributorsStatsInnerAuthor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PullRequestLinks"
        },
        {
            "name": "base",
            "baseName": "base",
            "type": "PullRequestBase"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "closedAt",
            "baseName": "closed_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "diffUrl",
            "baseName": "diff_url",
            "type": "string"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "PullRequestBase"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "issueUrl",
            "baseName": "issue_url",
            "type": "string"
        },
        {
            "name": "mergedAt",
            "baseName": "merged_at",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "patchUrl",
            "baseName": "patch_url",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "ContributorsStatsInnerAuthor"
        }    ];

    static getAttributeTypeMap() {
        return PullsInner.attributeTypeMap;
    }
}

export class PullsPost {
    'base'?: string;
    'body'?: string;
    'head'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "base",
            "baseName": "base",
            "type": "string"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "head",
            "baseName": "head",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PullsPost.attributeTypeMap;
    }
}

export class PutSubscription {
    'createdAt'?: string;
    'ignored'?: boolean;
    'reason'?: any;
    'subscribed'?: boolean;
    'threadUrl'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "ignored",
            "baseName": "ignored",
            "type": "boolean"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "any"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        },
        {
            "name": "threadUrl",
            "baseName": "thread_url",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PutSubscription.attributeTypeMap;
    }
}

export class RateLimit {
    'rate'?: RateLimitRate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rate",
            "baseName": "rate",
            "type": "RateLimitRate"
        }    ];

    static getAttributeTypeMap() {
        return RateLimit.attributeTypeMap;
    }
}

export class RateLimitRate {
    'limit'?: number;
    'remaining'?: number;
    'reset'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "remaining",
            "baseName": "remaining",
            "type": "number"
        },
        {
            "name": "reset",
            "baseName": "reset",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RateLimitRate.attributeTypeMap;
    }
}

export class Ref extends Array<RefInner> {

    static discriminator: string | undefined = undefined;

}

export class RefInner {
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'creator'?: ContributorsStatsInnerAuthor;
    'description'?: string;
    'id'?: number;
    'state'?: string;
    'targetUrl'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "ContributorsStatsInnerAuthor"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefInner.attributeTypeMap;
    }
}

export class RefStatus extends Array<RefStatusInner> {

    static discriminator: string | undefined = undefined;

}

export class RefStatusInner {
    'commitUrl'?: string;
    'name'?: string;
    'repositoryUrl'?: string;
    'sha'?: string;
    'state'?: string;
    'statuses'?: Array<RefStatusInnerStatuses>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commitUrl",
            "baseName": "commit_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "repositoryUrl",
            "baseName": "repository_url",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "statuses",
            "baseName": "statuses",
            "type": "Array<RefStatusInnerStatuses>"
        }    ];

    static getAttributeTypeMap() {
        return RefStatusInner.attributeTypeMap;
    }
}

export class RefStatusInnerStatuses {
    'context'?: string;
    'createdAt'?: string;
    'description'?: string;
    'id'?: number;
    'state'?: string;
    'targetUrl'?: string;
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "targetUrl",
            "baseName": "target_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefStatusInnerStatuses.attributeTypeMap;
    }
}

export class Refs extends Array<RefsInner> {

    static discriminator: string | undefined = undefined;

}

export class RefsBody {
    'ref'?: string;
    'sha'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefsBody.attributeTypeMap;
    }
}

export class RefsInner {
    'object'?: HeadBranchObject;
    'ref'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "object",
            "baseName": "object",
            "type": "HeadBranchObject"
        },
        {
            "name": "ref",
            "baseName": "ref",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RefsInner.attributeTypeMap;
    }
}

export class Release {
    'assets'?: Array<ReleaseAssets>;
    'assetsUrl'?: string;
    'author'?: User;
    'body'?: string;
    'createdAt'?: string;
    'draft'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'name'?: string;
    'prerelease'?: boolean;
    'publishedAt'?: string;
    'tagName'?: string;
    'tarballUrl'?: string;
    'targetCommitish'?: string;
    'uploadUrl'?: string;
    'url'?: string;
    'zipballUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assets",
            "baseName": "assets",
            "type": "Array<ReleaseAssets>"
        },
        {
            "name": "assetsUrl",
            "baseName": "assets_url",
            "type": "string"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "publishedAt",
            "baseName": "published_at",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "tarballUrl",
            "baseName": "tarball_url",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        },
        {
            "name": "uploadUrl",
            "baseName": "upload_url",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "zipballUrl",
            "baseName": "zipball_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Release.attributeTypeMap;
    }
}

export class ReleaseAssets {
    'contentType'?: string;
    'createdAt'?: string;
    'downloadCount'?: number;
    'id'?: number;
    'label'?: string;
    'name'?: string;
    'size'?: number;
    'state'?: string;
    'updatedAt'?: string;
    'uploader'?: User;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "contentType",
            "baseName": "content_type",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "downloadCount",
            "baseName": "download_count",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "uploader",
            "baseName": "uploader",
            "type": "User"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReleaseAssets.attributeTypeMap;
    }
}

export class ReleaseCreate {
    'body'?: string;
    'draft'?: boolean;
    'name'?: string;
    'prerelease'?: boolean;
    'tagName'?: string;
    'targetCommitish'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReleaseCreate.attributeTypeMap;
    }
}

export class Releases extends Array<ReleasesInner> {

    static discriminator: string | undefined = undefined;

}

export class ReleasesInner {
    'assets'?: Array<ReleaseAssets>;
    'assetsUrl'?: string;
    'author'?: User;
    'body'?: string;
    'createdAt'?: string;
    'draft'?: boolean;
    'htmlUrl'?: string;
    'id'?: number;
    'name'?: string;
    'prerelease'?: boolean;
    'publishedAt'?: string;
    'tagName'?: string;
    'tarballUrl'?: string;
    'targetCommitish'?: string;
    'uploadUrl'?: string;
    'url'?: string;
    'zipballUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "assets",
            "baseName": "assets",
            "type": "Array<ReleaseAssets>"
        },
        {
            "name": "assetsUrl",
            "baseName": "assets_url",
            "type": "string"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "User"
        },
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "draft",
            "baseName": "draft",
            "type": "boolean"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "prerelease",
            "baseName": "prerelease",
            "type": "boolean"
        },
        {
            "name": "publishedAt",
            "baseName": "published_at",
            "type": "string"
        },
        {
            "name": "tagName",
            "baseName": "tag_name",
            "type": "string"
        },
        {
            "name": "tarballUrl",
            "baseName": "tarball_url",
            "type": "string"
        },
        {
            "name": "targetCommitish",
            "baseName": "target_commitish",
            "type": "string"
        },
        {
            "name": "uploadUrl",
            "baseName": "upload_url",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "zipballUrl",
            "baseName": "zipball_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReleasesInner.attributeTypeMap;
    }
}

export class Repo {
    'cloneUrl'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'description'?: string;
    'fork'?: boolean;
    'forks'?: number;
    'forksCount'?: number;
    'fullName'?: string;
    'gitUrl'?: string;
    'hasDownloads'?: boolean;
    'hasIssues'?: boolean;
    'hasWiki'?: boolean;
    'homepage'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'language'?: string;
    'masterBranch'?: string;
    'mirrorUrl'?: string;
    'name'?: string;
    'openIssues'?: number;
    'openIssuesCount'?: number;
    'organization'?: Organization;
    'owner'?: Actor;
    'parent'?: any;
    '_private'?: boolean;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'pushedAt'?: string;
    'size'?: number;
    'source'?: any;
    'sshUrl'?: string;
    'svnUrl'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'watchers'?: number;
    'watchersCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cloneUrl",
            "baseName": "clone_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "fork",
            "baseName": "fork",
            "type": "boolean"
        },
        {
            "name": "forks",
            "baseName": "forks",
            "type": "number"
        },
        {
            "name": "forksCount",
            "baseName": "forks_count",
            "type": "number"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "gitUrl",
            "baseName": "git_url",
            "type": "string"
        },
        {
            "name": "hasDownloads",
            "baseName": "has_downloads",
            "type": "boolean"
        },
        {
            "name": "hasIssues",
            "baseName": "has_issues",
            "type": "boolean"
        },
        {
            "name": "hasWiki",
            "baseName": "has_wiki",
            "type": "boolean"
        },
        {
            "name": "homepage",
            "baseName": "homepage",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "masterBranch",
            "baseName": "master_branch",
            "type": "string"
        },
        {
            "name": "mirrorUrl",
            "baseName": "mirror_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "openIssues",
            "baseName": "open_issues",
            "type": "number"
        },
        {
            "name": "openIssuesCount",
            "baseName": "open_issues_count",
            "type": "number"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "Organization"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "Actor"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "any"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "pushedAt",
            "baseName": "pushed_at",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "any"
        },
        {
            "name": "sshUrl",
            "baseName": "ssh_url",
            "type": "string"
        },
        {
            "name": "svnUrl",
            "baseName": "svn_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "watchers",
            "baseName": "watchers",
            "type": "number"
        },
        {
            "name": "watchersCount",
            "baseName": "watchers_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Repo.attributeTypeMap;
    }
}

export class RepoComments extends Array<RepoCommentsInner> {

    static discriminator: string | undefined = undefined;

}

export class RepoCommentsInner {
    'body'?: string;
    'commitId'?: string;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'line'?: number;
    'path'?: string;
    'position'?: number;
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commit_id",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "line",
            "baseName": "line",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return RepoCommentsInner.attributeTypeMap;
    }
}

export class RepoCommit {
    'author'?: BranchCommitCommitAuthor;
    'committer'?: BranchCommitCommitAuthor;
    'message'?: string;
    'parents'?: Array<BranchCommitCommitTree>;
    'sha'?: string;
    'tree'?: BranchCommitCommitTree;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "BranchCommitCommitAuthor"
        },
        {
            "name": "committer",
            "baseName": "committer",
            "type": "BranchCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<BranchCommitCommitTree>"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "BranchCommitCommitTree"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepoCommit.attributeTypeMap;
    }
}

export class RepoCommitBody {
    'author'?: ComparecommitsBaseCommitCommitAuthor;
    'message': string;
    'parents': Array<string>;
    'tree': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "ComparecommitsBaseCommitCommitAuthor"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "parents",
            "baseName": "parents",
            "type": "Array<string>"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepoCommitBody.attributeTypeMap;
    }
}

export class RepoDeployments extends Array<RepodeploymentsInner> {

    static discriminator: string | undefined = undefined;

}

export class RepoEdit {
    'description'?: string;
    'hasDownloads'?: boolean;
    'hasIssues'?: boolean;
    'hasWiki'?: boolean;
    'homepage'?: string;
    'name'?: string;
    '_private'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "hasDownloads",
            "baseName": "has_downloads",
            "type": "boolean"
        },
        {
            "name": "hasIssues",
            "baseName": "has_issues",
            "type": "boolean"
        },
        {
            "name": "hasWiki",
            "baseName": "has_wiki",
            "type": "boolean"
        },
        {
            "name": "homepage",
            "baseName": "homepage",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return RepoEdit.attributeTypeMap;
    }
}

export class RepodeploymentsInner {
    'createdAt'?: string;
    'creator'?: User;
    'description'?: string;
    'id'?: number;
    'payload'?: string;
    'sha'?: string;
    'statusesUrl'?: string;
    'updatedAt'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "User"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "payload",
            "baseName": "payload",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "statusesUrl",
            "baseName": "statuses_url",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepodeploymentsInner.attributeTypeMap;
    }
}

export class Repos extends Array<Repo> {

    static discriminator: string | undefined = undefined;

}

export class SearchCode {
    'items'?: Array<SearchcodeItems>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<SearchcodeItems>"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchCode.attributeTypeMap;
    }
}

export class SearchIssues {
    'items'?: Array<SearchissuesItems>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<SearchissuesItems>"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchIssues.attributeTypeMap;
    }
}

export class SearchIssuesByKeyword {
    'issues'?: Array<SearchissuesbykeywordIssues>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issues",
            "baseName": "issues",
            "type": "Array<SearchissuesbykeywordIssues>"
        }    ];

    static getAttributeTypeMap() {
        return SearchIssuesByKeyword.attributeTypeMap;
    }
}

export class SearchRepositories {
    'items'?: Array<Repo>;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<Repo>"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchRepositories.attributeTypeMap;
    }
}

export class SearchRepositoriesByKeyword {
    'repositories'?: Array<Repo>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "repositories",
            "baseName": "repositories",
            "type": "Array<Repo>"
        }    ];

    static getAttributeTypeMap() {
        return SearchRepositoriesByKeyword.attributeTypeMap;
    }
}

export class SearchUserByEmail {
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return SearchUserByEmail.attributeTypeMap;
    }
}

export class SearchUsers {
    'items'?: Users;
    'totalCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "items",
            "baseName": "items",
            "type": "Users"
        },
        {
            "name": "totalCount",
            "baseName": "total_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchUsers.attributeTypeMap;
    }
}

export class SearchUsersByKeyword {
    'users'?: Users;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Users"
        }    ];

    static getAttributeTypeMap() {
        return SearchUsersByKeyword.attributeTypeMap;
    }
}

export class SearchcodeItems {
    'gitUrl'?: string;
    'htmlUrl'?: string;
    'name'?: string;
    'path'?: string;
    'repository'?: SearchcodeRepository;
    'score'?: number;
    'sha'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "gitUrl",
            "baseName": "git_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "repository",
            "baseName": "repository",
            "type": "SearchcodeRepository"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchcodeItems.attributeTypeMap;
    }
}

export class SearchcodeRepository {
    'archiveUrl'?: string;
    'assigneesUrl'?: string;
    'blobsUrl'?: string;
    'branchesUrl'?: string;
    'collaboratorsUrl'?: string;
    'commentsUrl'?: string;
    'commitsUrl'?: string;
    'compareUrl'?: string;
    'contentsUrl'?: string;
    'contributorsUrl'?: string;
    'description'?: string;
    'downloadsUrl'?: string;
    'eventsUrl'?: string;
    'fork'?: boolean;
    'forksUrl'?: string;
    'fullName'?: string;
    'gitCommitsUrl'?: string;
    'gitRefsUrl'?: string;
    'gitTagsUrl'?: string;
    'hooksUrl'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'issueCommentUrl'?: string;
    'issueEventsUrl'?: string;
    'issuesUrl'?: string;
    'keysUrl'?: string;
    'labelsUrl'?: string;
    'languagesUrl'?: string;
    'mergesUrl'?: string;
    'milestonesUrl'?: string;
    'name'?: string;
    'notificationsUrl'?: string;
    'owner'?: Actor;
    '_private'?: boolean;
    'pullsUrl'?: string;
    'stargazersUrl'?: string;
    'statusesUrl'?: string;
    'subscribersUrl'?: string;
    'subscriptionUrl'?: string;
    'tagsUrl'?: string;
    'teamsUrl'?: string;
    'treesUrl'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "archiveUrl",
            "baseName": "archive_url",
            "type": "string"
        },
        {
            "name": "assigneesUrl",
            "baseName": "assignees_url",
            "type": "string"
        },
        {
            "name": "blobsUrl",
            "baseName": "blobs_url",
            "type": "string"
        },
        {
            "name": "branchesUrl",
            "baseName": "branches_url",
            "type": "string"
        },
        {
            "name": "collaboratorsUrl",
            "baseName": "collaborators_url",
            "type": "string"
        },
        {
            "name": "commentsUrl",
            "baseName": "comments_url",
            "type": "string"
        },
        {
            "name": "commitsUrl",
            "baseName": "commits_url",
            "type": "string"
        },
        {
            "name": "compareUrl",
            "baseName": "compare_url",
            "type": "string"
        },
        {
            "name": "contentsUrl",
            "baseName": "contents_url",
            "type": "string"
        },
        {
            "name": "contributorsUrl",
            "baseName": "contributors_url",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "downloadsUrl",
            "baseName": "downloads_url",
            "type": "string"
        },
        {
            "name": "eventsUrl",
            "baseName": "events_url",
            "type": "string"
        },
        {
            "name": "fork",
            "baseName": "fork",
            "type": "boolean"
        },
        {
            "name": "forksUrl",
            "baseName": "forks_url",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "full_name",
            "type": "string"
        },
        {
            "name": "gitCommitsUrl",
            "baseName": "git_commits_url",
            "type": "string"
        },
        {
            "name": "gitRefsUrl",
            "baseName": "git_refs_url",
            "type": "string"
        },
        {
            "name": "gitTagsUrl",
            "baseName": "git_tags_url",
            "type": "string"
        },
        {
            "name": "hooksUrl",
            "baseName": "hooks_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "issueCommentUrl",
            "baseName": "issue_comment_url",
            "type": "string"
        },
        {
            "name": "issueEventsUrl",
            "baseName": "issue_events_url",
            "type": "string"
        },
        {
            "name": "issuesUrl",
            "baseName": "issues_url",
            "type": "string"
        },
        {
            "name": "keysUrl",
            "baseName": "keys_url",
            "type": "string"
        },
        {
            "name": "labelsUrl",
            "baseName": "labels_url",
            "type": "string"
        },
        {
            "name": "languagesUrl",
            "baseName": "languages_url",
            "type": "string"
        },
        {
            "name": "mergesUrl",
            "baseName": "merges_url",
            "type": "string"
        },
        {
            "name": "milestonesUrl",
            "baseName": "milestones_url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "notificationsUrl",
            "baseName": "notifications_url",
            "type": "string"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "Actor"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "pullsUrl",
            "baseName": "pulls_url",
            "type": "string"
        },
        {
            "name": "stargazersUrl",
            "baseName": "stargazers_url",
            "type": "string"
        },
        {
            "name": "statusesUrl",
            "baseName": "statuses_url",
            "type": "string"
        },
        {
            "name": "subscribersUrl",
            "baseName": "subscribers_url",
            "type": "string"
        },
        {
            "name": "subscriptionUrl",
            "baseName": "subscription_url",
            "type": "string"
        },
        {
            "name": "tagsUrl",
            "baseName": "tags_url",
            "type": "string"
        },
        {
            "name": "teamsUrl",
            "baseName": "teams_url",
            "type": "string"
        },
        {
            "name": "treesUrl",
            "baseName": "trees_url",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchcodeRepository.attributeTypeMap;
    }
}

export class SearchissuesItems {
    'body'?: string;
    'comments'?: number;
    'commentsUrl'?: string;
    'createdAt'?: string;
    'eventsUrl'?: string;
    'htmlUrl'?: string;
    'id'?: number;
    'labels'?: Array<IssueEventIssueLabels>;
    'labelsUrl'?: string;
    'number'?: number;
    'pullRequest'?: any;
    'score'?: number;
    'state'?: string;
    'title'?: string;
    'updatedAt'?: string;
    'url'?: string;
    'user'?: User;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "commentsUrl",
            "baseName": "comments_url",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "eventsUrl",
            "baseName": "events_url",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<IssueEventIssueLabels>"
        },
        {
            "name": "labelsUrl",
            "baseName": "labels_url",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "pullRequest",
            "baseName": "pull_request",
            "type": "any"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "User"
        }    ];

    static getAttributeTypeMap() {
        return SearchissuesItems.attributeTypeMap;
    }
}

export class SearchissuesbykeywordIssues {
    'body'?: string;
    'comments'?: number;
    'createdAt'?: string;
    'gravatarId'?: string;
    'htmlUrl'?: string;
    'labels'?: Array<string>;
    'number'?: number;
    'position'?: number;
    'state'?: string;
    'title'?: string;
    'updatedAt'?: string;
    'user'?: string;
    'votes'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "body",
            "baseName": "body",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "gravatarId",
            "baseName": "gravatar_id",
            "type": "string"
        },
        {
            "name": "htmlUrl",
            "baseName": "html_url",
            "type": "string"
        },
        {
            "name": "labels",
            "baseName": "labels",
            "type": "Array<string>"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "user",
            "baseName": "user",
            "type": "string"
        },
        {
            "name": "votes",
            "baseName": "votes",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SearchissuesbykeywordIssues.attributeTypeMap;
    }
}

export class Subscription {
    /**
    * ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'createdAt'?: string;
    'ignored'?: boolean;
    'reason'?: string;
    'repositoryUrl'?: string;
    'subscribed'?: boolean;
    'threadUrl'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "ignored",
            "baseName": "ignored",
            "type": "boolean"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "repositoryUrl",
            "baseName": "repository_url",
            "type": "string"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        },
        {
            "name": "threadUrl",
            "baseName": "thread_url",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Subscription.attributeTypeMap;
    }
}

export class SubscriptionBody {
    'ignored'?: boolean;
    'subscribed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ignored",
            "baseName": "ignored",
            "type": "boolean"
        },
        {
            "name": "subscribed",
            "baseName": "subscribed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionBody.attributeTypeMap;
    }
}

export class Tag {
    /**
    * String of the tag message.
    */
    'message'?: string;
    'object'?: TagObject;
    'sha'?: string;
    /**
    * The tag's name. This is typically a version (e.g., \"v0.0.1\").
    */
    'tag'?: string;
    'tagger'?: TagTagger;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "TagObject"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tagger",
            "baseName": "tagger",
            "type": "TagTagger"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tag.attributeTypeMap;
    }
}

export class TagBody {
    /**
    * String of the tag message.
    */
    'message': string;
    /**
    * String of the SHA of the git object this is tagging.
    */
    'object': string;
    /**
    * The tag's name. This is typically a version (e.g., \"v0.0.1\").
    */
    'tag': string;
    'tagger': TagTagger;
    /**
    * String of the type of the object weâ€™re tagging. Normally this is a commit but it can also be a tree or a blob.
    */
    'type': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "tag",
            "baseName": "tag",
            "type": "string"
        },
        {
            "name": "tagger",
            "baseName": "tagger",
            "type": "TagTagger"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagBody.attributeTypeMap;
    }
}

export class TagObject {
    'sha'?: string;
    /**
    * String of the type of the tagged object. Normally this is a commit but it can also be a tree or a blob.
    */
    'type'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagObject.attributeTypeMap;
    }
}

export class TagTagger {
    /**
    * Timestamp of when this object was tagged, in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ
    */
    'date'?: string;
    /**
    * String of the email of the author of the tag.
    */
    'email'?: string;
    /**
    * String of the name of the author of the tag.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TagTagger.attributeTypeMap;
    }
}

export class Tags extends Array<Tag> {

    static discriminator: string | undefined = undefined;

}

export class Team {
    'id'?: number;
    'membersCount'?: number;
    'name'?: string;
    'permission'?: string;
    'reposCount'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "membersCount",
            "baseName": "members_count",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        },
        {
            "name": "reposCount",
            "baseName": "repos_count",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Team.attributeTypeMap;
    }
}

export class TeamMembership {
    'state'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamMembership.attributeTypeMap;
    }
}

export class TeamRepos {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return TeamRepos.attributeTypeMap;
    }
}

export class Teams extends Array<EventRepo> {

    static discriminator: string | undefined = undefined;

}

export class TeamsList extends Array<TeamslistInner> {

    static discriminator: string | undefined = undefined;

}

export class TeamslistInner {
    'id'?: number;
    'membersCount'?: number;
    'name'?: string;
    'organization'?: TeamslistInnerOrganization;
    'permission'?: string;
    'reposCount'?: number;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "membersCount",
            "baseName": "members_count",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "TeamslistInnerOrganization"
        },
        {
            "name": "permission",
            "baseName": "permission",
            "type": "string"
        },
        {
            "name": "reposCount",
            "baseName": "repos_count",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamslistInner.attributeTypeMap;
    }
}

export class TeamslistInnerOrganization {
    'avatarUrl'?: string;
    'id'?: number;
    'login'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avatarUrl",
            "baseName": "avatar_url",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "login",
            "baseName": "login",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TeamslistInnerOrganization.attributeTypeMap;
    }
}

export class Tree {
    'sha'?: string;
    'tree'?: Array<TreeTree>;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "Array<TreeTree>"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tree.attributeTypeMap;
    }
}

export class TreeTree {
    /**
    * One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink.
    */
    'mode'?: TreeTree.ModeEnum;
    'path'?: string;
    /**
    * SHA1 checksum ID of the object in the tree.
    */
    'sha'?: string;
    'size'?: number;
    'type'?: TreeTree.TypeEnum;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "TreeTree.ModeEnum"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TreeTree.TypeEnum"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TreeTree.attributeTypeMap;
    }
}

export namespace TreeTree {
    export enum ModeEnum {
        _100644 = <any> '100644',
        _100755 = <any> '100755',
        _040000 = <any> '040000',
        _160000 = <any> '160000',
        _120000 = <any> '120000'
    }
    export enum TypeEnum {
        Blob = <any> 'blob',
        Tree = <any> 'tree',
        Commit = <any> 'commit'
    }
}
export class Trees {
    'baseTree'?: string;
    /**
    * SHA1 checksum ID of the object in the tree.
    */
    'sha'?: string;
    'tree'?: Array<Tree>;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "baseTree",
            "baseName": "base_tree",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "tree",
            "baseName": "tree",
            "type": "Array<Tree>"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Trees.attributeTypeMap;
    }
}

export class User extends Actor {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(User.attributeTypeMap);
    }
}

export class UserEmails extends Array<string> {

    static discriminator: string | undefined = undefined;

}

export class UserKeysKeyId {
    'id'?: number;
    'key'?: string;
    'title'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserKeysKeyId.attributeTypeMap;
    }
}

export class UserKeysPost {
    'key'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserKeysPost.attributeTypeMap;
    }
}

export class UserUpdate {
    'bio'?: string;
    'blog'?: string;
    'company'?: string;
    'email'?: string;
    'hireable'?: boolean;
    'location'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bio",
            "baseName": "bio",
            "type": "string"
        },
        {
            "name": "blog",
            "baseName": "blog",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "hireable",
            "baseName": "hireable",
            "type": "boolean"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserUpdate.attributeTypeMap;
    }
}

export class Users extends Array<User> {

    static discriminator: string | undefined = undefined;

}


let enumsMap: {[index: string]: any} = {
        "TreeTree.ModeEnum": TreeTree.ModeEnum,
        "TreeTree.TypeEnum": TreeTree.TypeEnum,
}

let typeMap: {[index: string]: any} = {
    "Actor": Actor,
    "ActorPlan": ActorPlan,
    "Asset": Asset,
    "AssetPatch": AssetPatch,
    "Assets": Assets,
    "Assignees": Assignees,
    "Blob": Blob,
    "Blobs": Blobs,
    "Branch": Branch,
    "BranchCommit": BranchCommit,
    "BranchCommitCommit": BranchCommitCommit,
    "BranchCommitCommitAuthor": BranchCommitCommitAuthor,
    "BranchCommitCommitTree": BranchCommitCommitTree,
    "BranchLinks": BranchLinks,
    "Branches": Branches,
    "BranchesInner": BranchesInner,
    "CodeFrequencyStats": CodeFrequencyStats,
    "Comment": Comment,
    "CommentBody": CommentBody,
    "Comments": Comments,
    "CommentsInner": CommentsInner,
    "Commit": Commit,
    "CommitActivityStats": CommitActivityStats,
    "CommitActivityStatsInner": CommitActivityStatsInner,
    "CommitComment": CommitComment,
    "CommitCommentBody": CommitCommentBody,
    "CommitFiles": CommitFiles,
    "CommitStats": CommitStats,
    "Commits": Commits,
    "CompareCommits": CompareCommits,
    "ComparecommitsBaseCommit": ComparecommitsBaseCommit,
    "ComparecommitsBaseCommitCommit": ComparecommitsBaseCommitCommit,
    "ComparecommitsBaseCommitCommitAuthor": ComparecommitsBaseCommitCommitAuthor,
    "ComparecommitsFiles": ComparecommitsFiles,
    "ContentsPath": ContentsPath,
    "ContentspathLinks": ContentspathLinks,
    "ContributorsStats": ContributorsStats,
    "ContributorsStatsInner": ContributorsStatsInner,
    "ContributorsStatsInnerAuthor": ContributorsStatsInnerAuthor,
    "ContributorsStatsInnerWeeks": ContributorsStatsInnerWeeks,
    "CreateFile": CreateFile,
    "CreateFileBody": CreateFileBody,
    "CreateFileBodyCommitter": CreateFileBodyCommitter,
    "CreateFileCommit": CreateFileCommit,
    "CreateFileCommitParents": CreateFileCommitParents,
    "CreateFileContent": CreateFileContent,
    "DeleteFile": DeleteFile,
    "DeleteFileBody": DeleteFileBody,
    "DeleteFileCommit": DeleteFileCommit,
    "Deployment": Deployment,
    "DeploymentPayload": DeploymentPayload,
    "DeploymentResp": DeploymentResp,
    "DeploymentStatuses": DeploymentStatuses,
    "DeploymentStatusesCreate": DeploymentStatusesCreate,
    "DeploymentstatusesInner": DeploymentstatusesInner,
    "Download": Download,
    "Downloads": Downloads,
    "EditTeam": EditTeam,
    "EmailsPost": EmailsPost,
    "Emojis": Emojis,
    "Event": Event,
    "EventRepo": EventRepo,
    "Events": Events,
    "Feeds": Feeds,
    "FeedsLinks": FeedsLinks,
    "FeedsLinksCurrentUser": FeedsLinksCurrentUser,
    "ForkBody": ForkBody,
    "Forks": Forks,
    "Gist": Gist,
    "GistFiles": GistFiles,
    "GistFilesRingErl": GistFilesRingErl,
    "GistForks": GistForks,
    "GistHistory": GistHistory,
    "Gists": Gists,
    "GistsInner": GistsInner,
    "GitCommit": GitCommit,
    "GitRefPatch": GitRefPatch,
    "Gitignore": Gitignore,
    "GitignoreLang": GitignoreLang,
    "HeadBranch": HeadBranch,
    "HeadBranchObject": HeadBranchObject,
    "Hook": Hook,
    "HookBody": HookBody,
    "HookInner": HookInner,
    "HookInnerConfig": HookInnerConfig,
    "Issue": Issue,
    "IssueEvent": IssueEvent,
    "IssueEventIssue": IssueEventIssue,
    "IssueEventIssueLabels": IssueEventIssueLabels,
    "IssueEventIssueMilestone": IssueEventIssueMilestone,
    "IssueEventIssuePullRequest": IssueEventIssuePullRequest,
    "IssueEvents": IssueEvents,
    "Issues": Issues,
    "IssuesComment": IssuesComment,
    "IssuesComments": IssuesComments,
    "IssuesCommentsInner": IssuesCommentsInner,
    "IssuesCommentsInnerLinks": IssuesCommentsInnerLinks,
    "IssuesCommentsInnerLinksHtml": IssuesCommentsInnerLinksHtml,
    "Keys": Keys,
    "KeysInner": KeysInner,
    "Label": Label,
    "Labels": Labels,
    "LabelsInner": LabelsInner,
    "Languages": Languages,
    "Markdown": Markdown,
    "Merge": Merge,
    "MergePullBody": MergePullBody,
    "MergesBody": MergesBody,
    "MergesConflict": MergesConflict,
    "MergesSuccessful": MergesSuccessful,
    "MergesSuccessfulCommit": MergesSuccessfulCommit,
    "Meta": Meta,
    "Milestone": Milestone,
    "MilestoneUpdate": MilestoneUpdate,
    "NotificationMarkRead": NotificationMarkRead,
    "Notifications": Notifications,
    "NotificationsRepository": NotificationsRepository,
    "NotificationsSubject": NotificationsSubject,
    "OrgTeamsPost": OrgTeamsPost,
    "Organization": Organization,
    "OrganizationAsTeamMember": OrganizationAsTeamMember,
    "OrganizationAsTeamMemberErrors": OrganizationAsTeamMemberErrors,
    "ParticipationStats": ParticipationStats,
    "PatchGist": PatchGist,
    "PatchGistFiles": PatchGistFiles,
    "PatchGistFilesFile1Txt": PatchGistFilesFile1Txt,
    "PatchGistFilesOldNameTxt": PatchGistFilesOldNameTxt,
    "PatchOrg": PatchOrg,
    "PostGist": PostGist,
    "PostGistFiles": PostGistFiles,
    "PostRepo": PostRepo,
    "PullRequest": PullRequest,
    "PullRequestBase": PullRequestBase,
    "PullRequestLinks": PullRequestLinks,
    "PullUpdate": PullUpdate,
    "Pulls": Pulls,
    "PullsComment": PullsComment,
    "PullsCommentPost": PullsCommentPost,
    "PullsComments": PullsComments,
    "PullsCommentsInner": PullsCommentsInner,
    "PullsInner": PullsInner,
    "PullsPost": PullsPost,
    "PutSubscription": PutSubscription,
    "RateLimit": RateLimit,
    "RateLimitRate": RateLimitRate,
    "Ref": Ref,
    "RefInner": RefInner,
    "RefStatus": RefStatus,
    "RefStatusInner": RefStatusInner,
    "RefStatusInnerStatuses": RefStatusInnerStatuses,
    "Refs": Refs,
    "RefsBody": RefsBody,
    "RefsInner": RefsInner,
    "Release": Release,
    "ReleaseAssets": ReleaseAssets,
    "ReleaseCreate": ReleaseCreate,
    "Releases": Releases,
    "ReleasesInner": ReleasesInner,
    "Repo": Repo,
    "RepoComments": RepoComments,
    "RepoCommentsInner": RepoCommentsInner,
    "RepoCommit": RepoCommit,
    "RepoCommitBody": RepoCommitBody,
    "RepoDeployments": RepoDeployments,
    "RepoEdit": RepoEdit,
    "RepodeploymentsInner": RepodeploymentsInner,
    "Repos": Repos,
    "SearchCode": SearchCode,
    "SearchIssues": SearchIssues,
    "SearchIssuesByKeyword": SearchIssuesByKeyword,
    "SearchRepositories": SearchRepositories,
    "SearchRepositoriesByKeyword": SearchRepositoriesByKeyword,
    "SearchUserByEmail": SearchUserByEmail,
    "SearchUsers": SearchUsers,
    "SearchUsersByKeyword": SearchUsersByKeyword,
    "SearchcodeItems": SearchcodeItems,
    "SearchcodeRepository": SearchcodeRepository,
    "SearchissuesItems": SearchissuesItems,
    "SearchissuesbykeywordIssues": SearchissuesbykeywordIssues,
    "Subscription": Subscription,
    "SubscriptionBody": SubscriptionBody,
    "Tag": Tag,
    "TagBody": TagBody,
    "TagObject": TagObject,
    "TagTagger": TagTagger,
    "Tags": Tags,
    "Team": Team,
    "TeamMembership": TeamMembership,
    "TeamRepos": TeamRepos,
    "Teams": Teams,
    "TeamsList": TeamsList,
    "TeamslistInner": TeamslistInner,
    "TeamslistInnerOrganization": TeamslistInnerOrganization,
    "Tree": Tree,
    "TreeTree": TreeTree,
    "Trees": Trees,
    "User": User,
    "UserEmails": UserEmails,
    "UserKeysKeyId": UserKeysKeyId,
    "UserKeysPost": UserKeysPost,
    "UserUpdate": UserUpdate,
    "Users": Users,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
}

export class GithubApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'oauth_2_0': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
      this.setDefaultHeader(this.defaultHeaders);
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
    	this.authentications.default = auth;
    }

    public setDefaultHeader(header: localVarRequest.Headers) {
	    this.defaultHeaders = header;
      this.defaultHeaders['User-Agent'] = 'dotup-ts-github-api';
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.oauth_2_0.accessToken = token;
    }
    /**
     * Lists all the emojis available to use on GitHub.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public emojisGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Emojis;  }> {
        const localVarPath = this.basePath + '/emojis';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Emojis;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Emojis");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public events.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public eventsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Events;  }> {
        const localVarPath = this.basePath + '/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Feeds. GitHub provides several timeline resources in Atom format. The Feeds API  lists all the feeds available to the authenticating user. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public feedsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Feeds;  }> {
        const localVarPath = this.basePath + '/feeds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Feeds;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feeds");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the authenticated user's gists or if called anonymously, this will return all public gists. 
     * @param since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ. Only gists updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsGet (since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gists;  }> {
        const localVarPath = this.basePath + '/gists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a comment.
     * @param id Id of gist.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdCommentsCommentIdDelete (id: number, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}/comments/{commentId}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdCommentsCommentIdDelete.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling gistsIdCommentsCommentIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single comment.
     * @param id Id of gist.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdCommentsCommentIdGet (id: number, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/gists/{id}/comments/{commentId}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdCommentsCommentIdGet.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling gistsIdCommentsCommentIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a comment.
     * @param id Id of gist.
     * @param commentId Id of comment.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdCommentsCommentIdPatch (id: number, commentId: number, body: Comment, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/gists/{id}/comments/{commentId}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdCommentsCommentIdPatch.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling gistsIdCommentsCommentIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling gistsIdCommentsCommentIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Comment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments on a gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdCommentsGet (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comments;  }> {
        const localVarPath = this.basePath + '/gists/{id}/comments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdCommentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a commen
     * @param id Id of gist.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdCommentsPost (id: number, body: CommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Comment;  }> {
        const localVarPath = this.basePath + '/gists/{id}/comments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdCommentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling gistsIdCommentsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Comment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Comment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdDelete (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Fork a gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdForksPost (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}/forks'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdForksPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdGet (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gist;  }> {
        const localVarPath = this.basePath + '/gists/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gist;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gist");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a gist.
     * @param id Id of gist.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdPatch (id: number, body: PatchGist, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gist;  }> {
        const localVarPath = this.basePath + '/gists/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling gistsIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PatchGist")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gist;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gist");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unstar a gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdStarDelete (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}/star'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdStarDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if a gist is starred.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdStarGet (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}/star'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdStarGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Star a gist.
     * @param id Id of gist.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsIdStarPut (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/gists/{id}/star'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling gistsIdStarPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a gist.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsPost (body: PostGist, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gist;  }> {
        const localVarPath = this.basePath + '/gists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling gistsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PostGist")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gist;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gist");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public gists.
     * @param since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ. Only gists updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsPublicGet (since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gists;  }> {
        const localVarPath = this.basePath + '/gists/public';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the authenticated user's starred gists.
     * @param since Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ. Only gists updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gistsStarredGet (since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gists;  }> {
        const localVarPath = this.basePath + '/gists/starred';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Listing available templates. List all templates available to pass as an option when creating a repository. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gitignoreTemplatesGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/gitignore/templates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
      return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single template.
     * @param language 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public gitignoreTemplatesLanguageGet (language: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitignoreLang;  }> {
        const localVarPath = this.basePath + '/gitignore/templates/{language}'
            .replace('{' + 'language' + '}', encodeURIComponent(String(language)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'language' is not null or undefined
        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling gitignoreTemplatesLanguageGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitignoreLang;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitignoreLang");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List issues. List all issues across all the authenticated user's visible repositories. 
     * @param filter Issues assigned to you / created by you / mentioning you / you&#39;re subscribed to updates for / All issues the authenticated user can see 
     * @param state 
     * @param labels String list of comma separated Label names. Example - bug,ui,@high.
     * @param sort 
     * @param direction 
     * @param since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Only issues updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public issuesGet (filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all', state: 'open' | 'closed', labels: string, sort: 'created' | 'updated' | 'comments', direction: 'asc' | 'desc', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issues;  }> {
        const localVarPath = this.basePath + '/issues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'labels' is not null or undefined
        if (labels === null || labels === undefined) {
            throw new Error('Required parameter labels was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'sort' is not null or undefined
        if (sort === null || sort === undefined) {
            throw new Error('Required parameter sort was null or undefined when calling issuesGet.');
        }

        // verify required parameter 'direction' is not null or undefined
        if (direction === null || direction === undefined) {
            throw new Error('Required parameter direction was null or undefined when calling issuesGet.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find issues by state and keyword.
     * @param keyword The search term.
     * @param state Indicates the state of the issues to return. Can be either open or closed.
     * @param owner 
     * @param repository 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public legacyIssuesSearchOwnerRepositoryStateKeywordGet (keyword: string, state: 'open' | 'closed', owner: string, repository: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchIssuesByKeyword;  }> {
        const localVarPath = this.basePath + '/legacy/issues/search/{owner}/{repository}/{state}/{keyword}'
            .replace('{' + 'keyword' + '}', encodeURIComponent(String(keyword)))
            .replace('{' + 'state' + '}', encodeURIComponent(String(state)))
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repository' + '}', encodeURIComponent(String(repository)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'keyword' is not null or undefined
        if (keyword === null || keyword === undefined) {
            throw new Error('Required parameter keyword was null or undefined when calling legacyIssuesSearchOwnerRepositoryStateKeywordGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling legacyIssuesSearchOwnerRepositoryStateKeywordGet.');
        }

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling legacyIssuesSearchOwnerRepositoryStateKeywordGet.');
        }

        // verify required parameter 'repository' is not null or undefined
        if (repository === null || repository === undefined) {
            throw new Error('Required parameter repository was null or undefined when calling legacyIssuesSearchOwnerRepositoryStateKeywordGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchIssuesByKeyword;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchIssuesByKeyword");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find repositories by keyword. Note, this legacy method does not follow the v3 pagination pattern. This method returns up to 100 results per page and pages can be fetched using the start_page parameter.
     * @param keyword The search term
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param language Filter results by language
     * @param startPage The page number to fetch
     * @param sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public legacyReposSearchKeywordGet (keyword: string, order?: 'desc' | 'asc', language?: string, startPage?: string, sort?: 'updated' | 'stars' | 'forks', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchRepositoriesByKeyword;  }> {
        const localVarPath = this.basePath + '/legacy/repos/search/{keyword}'
            .replace('{' + 'keyword' + '}', encodeURIComponent(String(keyword)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'keyword' is not null or undefined
        if (keyword === null || keyword === undefined) {
            throw new Error('Required parameter keyword was null or undefined when calling legacyReposSearchKeywordGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (language !== undefined) {
            localVarQueryParameters['language'] = ObjectSerializer.serialize(language, "string");
        }

        if (startPage !== undefined) {
            localVarQueryParameters['start_page'] = ObjectSerializer.serialize(startPage, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'updated' | 'stars' | 'forks'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchRepositoriesByKeyword;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchRepositoriesByKeyword");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This API call is added for compatibility reasons only.
     * @param email The email address
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public legacyUserEmailEmailGet (email: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchUserByEmail;  }> {
        const localVarPath = this.basePath + '/legacy/user/email/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling legacyUserEmailEmailGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchUserByEmail;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchUserByEmail");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find users by keyword.
     * @param keyword The search term
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param startPage The page number to fetch
     * @param sort The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public legacyUserSearchKeywordGet (keyword: string, order?: 'desc' | 'asc', startPage?: string, sort?: 'updated' | 'stars' | 'forks', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchUsersByKeyword;  }> {
        const localVarPath = this.basePath + '/legacy/user/search/{keyword}'
            .replace('{' + 'keyword' + '}', encodeURIComponent(String(keyword)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'keyword' is not null or undefined
        if (keyword === null || keyword === undefined) {
            throw new Error('Required parameter keyword was null or undefined when calling legacyUserSearchKeywordGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (startPage !== undefined) {
            localVarQueryParameters['start_page'] = ObjectSerializer.serialize(startPage, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'updated' | 'stars' | 'forks'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchUsersByKeyword;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchUsersByKeyword");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Render an arbitrary Markdown document
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public markdownPost (body: Markdown, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/markdown';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling markdownPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Markdown")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Render a Markdown document in raw mode
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public markdownRawPost (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/markdown/raw';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This gives some information about GitHub.com, the service.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public metaGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Meta;  }> {
        const localVarPath = this.basePath + '/meta';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Meta;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Meta");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public events for a network of repositories.
     * @param owner Name of the owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public networksOwnerRepoEventsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Events;  }> {
        const localVarPath = this.basePath + '/networks/{owner}/{repo}/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling networksOwnerRepoEventsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling networksOwnerRepoEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List your notifications. List all notifications for the current user, grouped by repository. 
     * @param all True to show notifications marked as read.
     * @param participating True to show only notifications in which the user is directly participating or mentioned. 
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsGet (all?: boolean, participating?: boolean, since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Notifications;  }> {
        const localVarPath = this.basePath + '/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "boolean");
        }

        if (participating !== undefined) {
            localVarQueryParameters['participating'] = ObjectSerializer.serialize(participating, "boolean");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Notifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Notifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark as read. Marking a notification as \"read\" removes it from the default view on GitHub.com. 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsPut (body: NotificationMarkRead, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/notifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling notificationsPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NotificationMarkRead")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * View a single thread.
     * @param id Id of thread.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsThreadsIdGet (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Notifications;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notificationsThreadsIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Notifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Notifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark a thread as read
     * @param id Id of thread.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsThreadsIdPatch (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notificationsThreadsIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Thread Subscription.
     * @param id Id of thread.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsThreadsIdSubscriptionDelete (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}/subscription'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notificationsThreadsIdSubscriptionDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Thread Subscription.
     * @param id Id of thread.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsThreadsIdSubscriptionGet (id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}/subscription'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notificationsThreadsIdSubscriptionGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set a Thread Subscription. This lets you subscribe to a thread, or ignore it. Subscribing to a thread is unnecessary if the user is already subscribed to the repository. Ignoring a thread will mute all future notifications (until you comment or get @mentioned). 
     * @param id Id of thread.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public notificationsThreadsIdSubscriptionPut (id: number, body: PutSubscription, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/notifications/threads/{id}/subscription'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling notificationsThreadsIdSubscriptionPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling notificationsThreadsIdSubscriptionPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PutSubscription")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public events for an organization.
     * @param org Name of organisation.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgEventsGet (org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Events;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/events'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an Organization.
     * @param org Name of organisation.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgGet (org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/orgs/{org}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List issues. List all issues for a given organization for the authenticated user. 
     * @param org Name of organisation.
     * @param filter Issues assigned to you / created by you / mentioning you / you&#39;re subscribed to updates for / All issues the authenticated user can see 
     * @param state 
     * @param labels String list of comma separated Label names. Example - bug,ui,@high.
     * @param sort 
     * @param direction 
     * @param since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Only issues updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgIssuesGet (org: string, filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all', state: 'open' | 'closed', labels: string, sort: 'created' | 'updated' | 'comments', direction: 'asc' | 'desc', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issues;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/issues'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgIssuesGet.');
        }

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling orgsOrgIssuesGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling orgsOrgIssuesGet.');
        }

        // verify required parameter 'labels' is not null or undefined
        if (labels === null || labels === undefined) {
            throw new Error('Required parameter labels was null or undefined when calling orgsOrgIssuesGet.');
        }

        // verify required parameter 'sort' is not null or undefined
        if (sort === null || sort === undefined) {
            throw new Error('Required parameter sort was null or undefined when calling orgsOrgIssuesGet.');
        }

        // verify required parameter 'direction' is not null or undefined
        if (direction === null || direction === undefined) {
            throw new Error('Required parameter direction was null or undefined when calling orgsOrgIssuesGet.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Members list. List all users who are members of an organization. A member is a user tha belongs to at least 1 team in the organization. If the authenticated user is also an owner of this organization then both concealed and public members will be returned. If the requester is not an owner of the organization the query will be redirected to the public members list. 
     * @param org Name of organisation.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgMembersGet (org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgMembersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a member. Removing a user from this list will remove them from all teams and they will no longer have any access to the organization's repositories. 
     * @param org Name of organisation.
     * @param username Name of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgMembersUsernameDelete (org: string, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgMembersUsernameDelete.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgsOrgMembersUsernameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if a user is, publicly or privately, a member of the organization.
     * @param org Name of organisation.
     * @param username Name of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgMembersUsernameGet (org: string, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgMembersUsernameGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgsOrgMembersUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit an Organization.
     * @param org Name of organisation.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgPatch (org: string, body: PatchOrg, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Organization;  }> {
        const localVarPath = this.basePath + '/orgs/{org}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling orgsOrgPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PatchOrg")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Organization;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organization");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Public members list. Members of an organization can choose to have their membership publicized or not. 
     * @param org Name of organisation.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgPublicMembersGet (org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgPublicMembersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Conceal a user's membership.
     * @param org Name of organisation.
     * @param username Name of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgPublicMembersUsernameDelete (org: string, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgPublicMembersUsernameDelete.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgsOrgPublicMembersUsernameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check public membership.
     * @param org Name of organisation.
     * @param username Name of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgPublicMembersUsernameGet (org: string, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgPublicMembersUsernameGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgsOrgPublicMembersUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Publicize a user's membership.
     * @param org Name of organisation.
     * @param username Name of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgPublicMembersUsernamePut (org: string, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/public_members/{username}'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgPublicMembersUsernamePut.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling orgsOrgPublicMembersUsernamePut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories for the specified org.
     * @param org Name of organisation.
     * @param type 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgReposGet (org: string, type?: 'all' | 'public' | 'private' | 'forks' | 'sources' | 'member', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/repos'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgReposGet.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'all' | 'public' | 'private' | 'forks' | 'sources' | 'member'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new repository for the authenticated user. OAuth users must supply repo scope. 
     * @param org Name of organisation.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgReposPost (org: string, body: PostRepo, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/repos'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgReposPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling orgsOrgReposPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PostRepo")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List teams.
     * @param org Name of organisation.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgTeamsGet (org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Teams;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgTeamsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Teams;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Teams");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create team. In order to create a team, the authenticated user must be an owner of organization. 
     * @param org Name of organisation.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public orgsOrgTeamsPost (org: string, body: OrgTeamsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/orgs/{org}/teams'
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling orgsOrgTeamsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling orgsOrgTeamsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "OrgTeamsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get your current rate limit status Note: Accessing this endpoint does not count against your rate limit. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public rateLimitGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RateLimit;  }> {
        const localVarPath = this.basePath + '/rate_limit';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RateLimit;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RateLimit");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get archive link. This method will return a 302 to a URL to download a tarball or zipball archive for a repository. Please make sure your HTTP framework is configured to follow redirects or you will need to use the Location header to make a second GET request. Note: For private repositories, these links are temporary and expire quickly. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param archiveFormat 
     * @param path Valid Git reference, defaults to &#39;master&#39;.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoArchiveFormatPathGet (owner: string, repo: string, archiveFormat: 'tarball' | 'zipball', path: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/{archive_format}/{path}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'archive_format' + '}', encodeURIComponent(String(archiveFormat)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoArchiveFormatPathGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoArchiveFormatPathGet.');
        }

        // verify required parameter 'archiveFormat' is not null or undefined
        if (archiveFormat === null || archiveFormat === undefined) {
            throw new Error('Required parameter archiveFormat was null or undefined when calling reposOwnerRepoArchiveFormatPathGet.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling reposOwnerRepoArchiveFormatPathGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check assignee. You may also check to see if a particular user is an assignee for a repository. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param assignee Login of the assignee.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoAssigneesAssigneeGet (owner: string, repo: string, assignee: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/assignees/{assignee}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'assignee' + '}', encodeURIComponent(String(assignee)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoAssigneesAssigneeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoAssigneesAssigneeGet.');
        }

        // verify required parameter 'assignee' is not null or undefined
        if (assignee === null || assignee === undefined) {
            throw new Error('Required parameter assignee was null or undefined when calling reposOwnerRepoAssigneesAssigneeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List assignees. This call lists all the available assignees (owner + collaborators) to which issues may be assigned. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoAssigneesGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Assignees;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/assignees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoAssigneesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoAssigneesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Assignees;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Assignees");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Branch
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param branch Name of the branch.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoBranchesBranchGet (owner: string, repo: string, branch: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Branch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches/{branch}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'branch' + '}', encodeURIComponent(String(branch)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoBranchesBranchGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoBranchesBranchGet.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling reposOwnerRepoBranchesBranchGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Branch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Branch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of branches
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoBranchesGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Branches;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/branches'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoBranchesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoBranchesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Branches;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Branches");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List. When authenticating as an organization owner of an organization-owned repository, all organization owners are included in the list of collaborators. Otherwise, only users with access to the repository are returned in the collaborators list. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCollaboratorsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCollaboratorsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCollaboratorsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove collaborator.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param user Login of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCollaboratorsUserDelete (owner: string, repo: string, user: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCollaboratorsUserDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCollaboratorsUserDelete.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling reposOwnerRepoCollaboratorsUserDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if user is a collaborator
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param user Login of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCollaboratorsUserGet (owner: string, repo: string, user: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCollaboratorsUserGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCollaboratorsUserGet.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling reposOwnerRepoCollaboratorsUserGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add collaborator.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param user Login of the user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCollaboratorsUserPut (owner: string, repo: string, user: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/collaborators/{user}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'user' + '}', encodeURIComponent(String(user)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCollaboratorsUserPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCollaboratorsUserPut.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling reposOwnerRepoCollaboratorsUserPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a commit comment
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommentsCommentIdDelete (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommentsCommentIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommentsCommentIdDelete.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoCommentsCommentIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single commit comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommentsCommentIdGet (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CommitComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommentsCommentIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommentsCommentIdGet.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoCommentsCommentIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CommitComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommitComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a commit comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommentsCommentIdPatch (owner: string, repo: string, commentId: number, body: CommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CommitComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommentsCommentIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommentsCommentIdPatch.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoCommentsCommentIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoCommentsCommentIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CommitComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommitComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List commit comments for a repository. Comments are ordered by ascending ID. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommentsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepoComments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepoComments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepoComments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List commits on a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param sha Sha or branch to start listing commits from.
     * @param path Only commits containing this file path will be returned.
     * @param author GitHub login, name, or email by which to filter by commit author.
     * @param until ISO 8601 Date - Only commits before this date will be returned.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommitsGet (owner: string, repo: string, since?: string, sha?: string, path?: string, author?: string, until?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Commits;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommitsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommitsGet.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        if (sha !== undefined) {
            localVarQueryParameters['sha'] = ObjectSerializer.serialize(sha, "string");
        }

        if (path !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path, "string");
        }

        if (author !== undefined) {
            localVarQueryParameters['author'] = ObjectSerializer.serialize(author, "string");
        }

        if (until !== undefined) {
            localVarQueryParameters['until'] = ObjectSerializer.serialize(until, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Commits;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Commits");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the combined Status for a specific Ref The Combined status endpoint is currently available for developers to preview. During the preview period, the API may change without advance notice. Please see the blog post for full details. To access this endpoint during the preview period, you must provide a custom media type in the Accept header: application/vnd.github.she-hulk-preview+json 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommitsRefStatusGet (owner: string, repo: string, ref: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RefStatus;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{ref}/status'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommitsRefStatusGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommitsRefStatusGet.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoCommitsRefStatusGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RefStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RefStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments for a single commitList comments for a single commit.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode SHA-1 code of the commit.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommitsShaCodeCommentsGet (owner: string, repo: string, shaCode: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepoComments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{shaCode}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepoComments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepoComments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a commit comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode SHA-1 code of the commit.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommitsShaCodeCommentsPost (owner: string, repo: string, shaCode: string, body: CommitCommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CommitComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{shaCode}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsPost.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoCommitsShaCodeCommentsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommitCommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CommitComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommitComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single commit.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode SHA-1 code of the commit.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCommitsShaCodeGet (owner: string, repo: string, shaCode: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Commit;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/commits/{shaCode}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCommitsShaCodeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCommitsShaCodeGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoCommitsShaCodeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Commit;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Commit");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Compare two commits
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param baseId 
     * @param headId 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoCompareBaseIdHeadIdGet (owner: string, repo: string, baseId: string, headId: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CompareCommits;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/compare/{baseId}...{headId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'baseId' + '}', encodeURIComponent(String(baseId)))
            .replace('{' + 'headId' + '}', encodeURIComponent(String(headId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoCompareBaseIdHeadIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoCompareBaseIdHeadIdGet.');
        }

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling reposOwnerRepoCompareBaseIdHeadIdGet.');
        }

        // verify required parameter 'headId' is not null or undefined
        if (headId === null || headId === undefined) {
            throw new Error('Required parameter headId was null or undefined when calling reposOwnerRepoCompareBaseIdHeadIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CompareCommits;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CompareCommits");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a file. This method deletes a file in a repository. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param path 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoContentsPathDelete (owner: string, repo: string, path: string, body: DeleteFileBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeleteFile;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{path}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoContentsPathDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoContentsPathDelete.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling reposOwnerRepoContentsPathDelete.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoContentsPathDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeleteFileBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeleteFile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeleteFile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contents. This method returns the contents of a file or directory in a repository. Files and symlinks support a custom media type for getting the raw content. Directories and submodules do not support custom media types. Note: This API supports files up to 1 megabyte in size. Here can be many outcomes. For details see \"http://developer.github.com/v3/repos/contents/\" 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param path 
     * @param path2 The content path.
     * @param ref The String name of the Commit/Branch/Tag. Defaults to &#39;master&#39;.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoContentsPathGet (owner: string, repo: string, path: string, path2?: string, ref?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ContentsPath;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{path}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoContentsPathGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoContentsPathGet.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling reposOwnerRepoContentsPathGet.');
        }

        if (path2 !== undefined) {
            localVarQueryParameters['path'] = ObjectSerializer.serialize(path2, "string");
        }

        if (ref !== undefined) {
            localVarQueryParameters['ref'] = ObjectSerializer.serialize(ref, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ContentsPath;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ContentsPath");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a file.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param path 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoContentsPathPut (owner: string, repo: string, path: string, body: CreateFileBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CreateFile;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contents/{path}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'path' + '}', encodeURIComponent(String(path)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoContentsPathPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoContentsPathPut.');
        }

        // verify required parameter 'path' is not null or undefined
        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling reposOwnerRepoContentsPathPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoContentsPathPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CreateFileBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CreateFile;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateFile");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of contributors.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param anon Set to 1 or true to include anonymous contributors in results.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoContributorsGet (owner: string, repo: string, anon: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/contributors'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoContributorsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoContributorsGet.');
        }

        // verify required parameter 'anon' is not null or undefined
        if (anon === null || anon === undefined) {
            throw new Error('Required parameter anon was null or undefined when calling reposOwnerRepoContributorsGet.');
        }

        if (anon !== undefined) {
            localVarQueryParameters['anon'] = ObjectSerializer.serialize(anon, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Repository. Deleting a repository requires admin access. If OAuth is used, the delete_repo scope is required. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDelete (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with pull access can view deployments for a repository
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDeploymentsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepoDeployments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/deployments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDeploymentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDeploymentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepoDeployments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepoDeployments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with pull access can view deployment statuses for a deployment
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id The Deployment ID to list the statuses from.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDeploymentsIdStatusesGet (owner: string, repo: string, id: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeploymentStatuses;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/deployments/{id}/statuses'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeploymentStatuses;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeploymentStatuses");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Deployment Status Users with push access can create deployment statuses for a given deployment: 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id The Deployment ID to list the statuses from.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDeploymentsIdStatusesPost (owner: string, repo: string, id: number, body: DeploymentStatusesCreate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/deployments/{id}/statuses'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesPost.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoDeploymentsIdStatusesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DeploymentStatusesCreate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with push access can create a deployment for a given ref
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDeploymentsPost (owner: string, repo: string, body: Deployment, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeploymentResp;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/deployments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDeploymentsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDeploymentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoDeploymentsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Deployment")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeploymentResp;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeploymentResp");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deprecated. Delete a download.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param downloadId Id of download.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDownloadsDownloadIdDelete (owner: string, repo: string, downloadId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/downloads/{downloadId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'downloadId' + '}', encodeURIComponent(String(downloadId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDownloadsDownloadIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDownloadsDownloadIdDelete.');
        }

        // verify required parameter 'downloadId' is not null or undefined
        if (downloadId === null || downloadId === undefined) {
            throw new Error('Required parameter downloadId was null or undefined when calling reposOwnerRepoDownloadsDownloadIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deprecated. Get a single download.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param downloadId Id of download.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDownloadsDownloadIdGet (owner: string, repo: string, downloadId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Download;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/downloads/{downloadId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'downloadId' + '}', encodeURIComponent(String(downloadId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDownloadsDownloadIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDownloadsDownloadIdGet.');
        }

        // verify required parameter 'downloadId' is not null or undefined
        if (downloadId === null || downloadId === undefined) {
            throw new Error('Required parameter downloadId was null or undefined when calling reposOwnerRepoDownloadsDownloadIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Download;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Download");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deprecated. List downloads for a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoDownloadsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Downloads;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/downloads'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoDownloadsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoDownloadsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Downloads;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Downloads");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of repository events.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoEventsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Events;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoEventsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Events;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Events");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List forks.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param sort 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoForksGet (owner: string, repo: string, sort?: 'newes' | 'oldes' | 'watchers', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Forks;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/forks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoForksGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoForksGet.');
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'newes' | 'oldes' | 'watchers'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Forks;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Forks");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a fork. Forking a Repository happens asynchronously. Therefore, you may have to wai a short period before accessing the git objects. If this takes longer than 5 minutes, be sure to contact Support. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoForksPost (owner: string, repo: string, body: ForkBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/forks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoForksPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoForksPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoForksPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ForkBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Blob.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitBlobsPost (owner: string, repo: string, body: Blob, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Blobs;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/blobs'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitBlobsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitBlobsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitBlobsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Blob")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Blobs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Blobs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Blob. Since blobs can be any arbitrary binary data, the input and responses for the blob API takes an encoding parameter that can be either utf-8 or base64. If your data cannot be losslessly sent as a UTF-8 string, you can base64 encode it. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode SHA-1 code.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitBlobsShaCodeGet (owner: string, repo: string, shaCode: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Blob;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/blobs/{shaCode}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitBlobsShaCodeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitBlobsShaCodeGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoGitBlobsShaCodeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Blob;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Blob");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Commit.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitCommitsPost (owner: string, repo: string, body: RepoCommitBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: GitCommit;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/commits'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitCommitsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitCommitsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitCommitsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RepoCommitBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: GitCommit;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GitCommit");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Commit.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode SHA-1 code.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitCommitsShaCodeGet (owner: string, repo: string, shaCode: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepoCommit;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/commits/{shaCode}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitCommitsShaCodeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitCommitsShaCodeGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoGitCommitsShaCodeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepoCommit;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepoCommit");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all References
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitRefsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Refs;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitRefsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitRefsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Refs;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Refs");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Reference
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitRefsPost (owner: string, repo: string, body: RefsBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HeadBranch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitRefsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitRefsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitRefsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RefsBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HeadBranch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HeadBranch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Reference Example: Deleting a branch: DELETE /repos/octocat/Hello-World/git/refs/heads/feature-a  Example: Deleting a tag:        DELETE /repos/octocat/Hello-World/git/refs/tags/v1.0 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitRefsRefDelete (owner: string, repo: string, ref: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitRefsRefDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitRefsRefDelete.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoGitRefsRefDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Reference
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitRefsRefGet (owner: string, repo: string, ref: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HeadBranch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitRefsRefGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitRefsRefGet.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoGitRefsRefGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HeadBranch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HeadBranch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Reference
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitRefsRefPatch (owner: string, repo: string, ref: string, body: GitRefPatch, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HeadBranch;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/refs/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitRefsRefPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitRefsRefPatch.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoGitRefsRefPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitRefsRefPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "GitRefPatch")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HeadBranch;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HeadBranch");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Tag Object. Note that creating a tag object does not create the reference that makes a tag in Git. If you want to create an annotated tag in Git, you have to do this call to create the tag object, and then create the refs/tags/[tag] reference. If you want to create a lightweight tag, you only have to create the tag reference - this call would be unnecessary. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitTagsPost (owner: string, repo: string, body: TagBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tag;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/tags'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitTagsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitTagsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitTagsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "TagBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Tag.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitTagsShaCodeGet (owner: string, repo: string, shaCode: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tag;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/tags/{shaCode}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitTagsShaCodeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitTagsShaCodeGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoGitTagsShaCodeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tag;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tag");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Tree. The tree creation API will take nested entries as well. If both a tree and a nested path modifying that tree are specified, it will overwrite the contents of that tree with the new path contents and write a new tree out. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitTreesPost (owner: string, repo: string, body: Tree, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Trees;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/trees'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitTreesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitTreesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoGitTreesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Tree")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Trees;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Trees");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Tree.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param shaCode Tree SHA.
     * @param recursive Get a Tree Recursively. (0 or 1)
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoGitTreesShaCodeGet (owner: string, repo: string, shaCode: string, recursive?: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tree;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/git/trees/{shaCode}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'shaCode' + '}', encodeURIComponent(String(shaCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoGitTreesShaCodeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoGitTreesShaCodeGet.');
        }

        // verify required parameter 'shaCode' is not null or undefined
        if (shaCode === null || shaCode === undefined) {
            throw new Error('Required parameter shaCode was null or undefined when calling reposOwnerRepoGitTreesShaCodeGet.');
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "number");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tree;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tree");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of hooks.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a hook.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param hookId Id of hook.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksHookIdDelete (owner: string, repo: string, hookId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{hookId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'hookId' + '}', encodeURIComponent(String(hookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksHookIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksHookIdDelete.');
        }

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error('Required parameter hookId was null or undefined when calling reposOwnerRepoHooksHookIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get single hook.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param hookId Id of hook.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksHookIdGet (owner: string, repo: string, hookId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{hookId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'hookId' + '}', encodeURIComponent(String(hookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksHookIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksHookIdGet.');
        }

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error('Required parameter hookId was null or undefined when calling reposOwnerRepoHooksHookIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a hook.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param hookId Id of hook.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksHookIdPatch (owner: string, repo: string, hookId: number, body: HookBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{hookId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'hookId' + '}', encodeURIComponent(String(hookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksHookIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksHookIdPatch.');
        }

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error('Required parameter hookId was null or undefined when calling reposOwnerRepoHooksHookIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoHooksHookIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "HookBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Test a push hook. This will trigger the hook with the latest push to the current repository if the hook is subscribed to push events. If the hook is not subscribed to push events, the server will respond with 204 but no test POST will be generated. Note: Previously /repos/:owner/:repo/hooks/:id/tes 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param hookId Id of hook.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksHookIdTestsPost (owner: string, repo: string, hookId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks/{hookId}/tests'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'hookId' + '}', encodeURIComponent(String(hookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksHookIdTestsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksHookIdTestsPost.');
        }

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error('Required parameter hookId was null or undefined when calling reposOwnerRepoHooksHookIdTestsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a hook.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoHooksPost (owner: string, repo: string, body: HookBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Hook;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/hooks'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoHooksPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoHooksPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoHooksPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "HookBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Hook;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hook");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId ID of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesCommentsCommentIdDelete (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdDelete.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId ID of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesCommentsCommentIdGet (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdGet.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId ID of comment.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesCommentsCommentIdPatch (owner: string, repo: string, commentId: number, body: CommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdPatch.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesCommentsCommentIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments in a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param direction Ignored without &#39;sort&#39; parameter.
     * @param sort 
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesCommentsGet (owner: string, repo: string, direction?: string, sort?: 'created' | 'updated', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesCommentsGet.');
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single event.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param eventId Id of the event.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesEventsEventIdGet (owner: string, repo: string, eventId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueEvent;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/events/{eventId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesEventsEventIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesEventsEventIdGet.');
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling reposOwnerRepoIssuesEventsEventIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueEvent;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueEvent");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List issue events for a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesEventsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueEvents;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesEventsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueEvents;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueEvents");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List issues for a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param filter Issues assigned to you / created by you / mentioning you / you&#39;re subscribed to updates for / All issues the authenticated user can see 
     * @param state 
     * @param labels String list of comma separated Label names. Example - bug,ui,@high.
     * @param sort 
     * @param direction 
     * @param since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Only issues updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesGet (owner: string, repo: string, filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all', state: 'open' | 'closed', labels: string, sort: 'created' | 'updated' | 'comments', direction: 'asc' | 'desc', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issues;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'labels' is not null or undefined
        if (labels === null || labels === undefined) {
            throw new Error('Required parameter labels was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'sort' is not null or undefined
        if (sort === null || sort === undefined) {
            throw new Error('Required parameter sort was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        // verify required parameter 'direction' is not null or undefined
        if (direction === null || direction === undefined) {
            throw new Error('Required parameter direction was null or undefined when calling reposOwnerRepoIssuesGet.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments on an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberCommentsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberCommentsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberCommentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberCommentsPost (owner: string, repo: string, number: number, body: CommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberCommentsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberCommentsPost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberCommentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesNumberCommentsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List events for an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberEventsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssueEvents;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/events'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberEventsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberEventsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssueEvents;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssueEvents");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single issue
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove all labels from an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberLabelsDelete (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberLabelsDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberLabelsDelete.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberLabelsDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List labels on an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberLabelsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Labels;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberLabelsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberLabelsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberLabelsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Labels;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Labels");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove a label from an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param name Name of the label.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberLabelsNameDelete (owner: string, repo: string, number: number, name: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberLabelsNameDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberLabelsNameDelete.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberLabelsNameDelete.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposOwnerRepoIssuesNumberLabelsNameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add labels to an issue.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberLabelsPost (owner: string, repo: string, number: number, body: EmailsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EmailsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replace all labels for an issue. Sending an empty array ([]) will remove all Labels from the Issue. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberLabelsPut (owner: string, repo: string, number: number, body: EmailsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPut.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesNumberLabelsPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EmailsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit an issue. Issue owners and users with push access can edit an issue. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of issue.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesNumberPatch (owner: string, repo: string, number: number, body: Issue, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesNumberPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesNumberPatch.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoIssuesNumberPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesNumberPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Issue")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create an issue. Any user with pull access to a repository can create an issue. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoIssuesPost (owner: string, repo: string, body: Issue, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issue;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/issues'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoIssuesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoIssuesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoIssuesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Issue")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issue;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issue");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of keys.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoKeysGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Keys;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoKeysGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoKeysGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Keys;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Keys");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a key.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param keyId Id of key.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoKeysKeyIdDelete (owner: string, repo: string, keyId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys/{keyId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoKeysKeyIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoKeysKeyIdDelete.');
        }

        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling reposOwnerRepoKeysKeyIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a key
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param keyId Id of key.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoKeysKeyIdGet (owner: string, repo: string, keyId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys/{keyId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoKeysKeyIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoKeysKeyIdGet.');
        }

        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling reposOwnerRepoKeysKeyIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserKeysKeyId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a key.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoKeysPost (owner: string, repo: string, body: UserKeysPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/keys'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoKeysPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoKeysPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoKeysPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserKeysPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserKeysKeyId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all labels for this repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLabelsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Labels;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLabelsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLabelsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Labels;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Labels");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a label.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param name Name of the label.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLabelsNameDelete (owner: string, repo: string, name: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLabelsNameDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLabelsNameDelete.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposOwnerRepoLabelsNameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single label.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param name Name of the label.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLabelsNameGet (owner: string, repo: string, name: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLabelsNameGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLabelsNameGet.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposOwnerRepoLabelsNameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a label.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param name Name of the label.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLabelsNamePatch (owner: string, repo: string, name: string, body: EmailsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels/{name}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLabelsNamePatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLabelsNamePatch.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling reposOwnerRepoLabelsNamePatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoLabelsNamePatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EmailsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a label.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLabelsPost (owner: string, repo: string, body: EmailsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Label;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLabelsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLabelsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoLabelsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EmailsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Label;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Label");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List languages. List languages for the specified repository. The value on the right of a language is the number of bytes of code written in that language. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoLanguagesGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Languages;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/languages'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoLanguagesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoLanguagesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Languages;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Languages");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Perform a merge.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMergesPost (owner: string, repo: string, body: MergesBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MergesSuccessful;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/merges'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMergesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMergesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoMergesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MergesBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MergesSuccessful;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MergesSuccessful");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List milestones for a repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param state String to filter by state.
     * @param direction Ignored without &#39;sort&#39; parameter.
     * @param sort 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesGet (owner: string, repo: string, state?: 'open' | 'closed', direction?: string, sort?: 'due_date' | 'completeness', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesGet.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'due_date' | 'completeness'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a milestone.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of milestone.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesNumberDelete (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesNumberDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesNumberDelete.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoMilestonesNumberDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single milestone.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of milestone.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesNumberGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesNumberGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesNumberGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoMilestonesNumberGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get labels for every issue in a milestone.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of milestone.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesNumberLabelsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Labels;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{number}/labels'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesNumberLabelsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesNumberLabelsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoMilestonesNumberLabelsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Labels;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Labels");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a milestone.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Number of milestone.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesNumberPatch (owner: string, repo: string, number: number, body: MilestoneUpdate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesNumberPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesNumberPatch.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoMilestonesNumberPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoMilestonesNumberPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MilestoneUpdate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a milestone.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoMilestonesPost (owner: string, repo: string, body: MilestoneUpdate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Milestone;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/milestones'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoMilestonesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoMilestonesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoMilestonesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MilestoneUpdate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Milestone;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Milestone");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List your notifications in a repository List all notifications for the current user. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param all True to show notifications marked as read.
     * @param participating True to show only notifications in which the user is directly participating or mentioned. 
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoNotificationsGet (owner: string, repo: string, all?: boolean, participating?: boolean, since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Notifications;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/notifications'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoNotificationsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoNotificationsGet.');
        }

        if (all !== undefined) {
            localVarQueryParameters['all'] = ObjectSerializer.serialize(all, "boolean");
        }

        if (participating !== undefined) {
            localVarQueryParameters['participating'] = ObjectSerializer.serialize(participating, "boolean");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Notifications;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Notifications");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Mark notifications as read in a repository. Marking all notifications in a repository as \"read\" removes them from the default view on GitHub.com. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoNotificationsPut (owner: string, repo: string, body: NotificationMarkRead, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/notifications'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoNotificationsPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoNotificationsPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoNotificationsPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "NotificationMarkRead")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit repository.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPatch (owner: string, repo: string, body: RepoEdit, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RepoEdit")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsCommentsCommentIdDelete (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdDelete.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsCommentsCommentIdGet (owner: string, repo: string, commentId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullsComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdGet.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullsComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullsComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a comment.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param commentId Id of comment.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsCommentsCommentIdPatch (owner: string, repo: string, commentId: number, body: CommentBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullsComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments/{commentId}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'commentId' + '}', encodeURIComponent(String(commentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdPatch.');
        }

        // verify required parameter 'commentId' is not null or undefined
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPullsCommentsCommentIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "CommentBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullsComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullsComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments in a repository. By default, Review Comments are ordered by ascending ID. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param direction Ignored without &#39;sort&#39; parameter.
     * @param sort 
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsCommentsGet (owner: string, repo: string, direction?: string, sort?: 'created' | 'updated', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: IssuesComments;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsCommentsGet.');
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: IssuesComments;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "IssuesComments");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List pull requests.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param state String to filter by state.
     * @param head Filter pulls by head user and branch name in the format of &#39;user:ref-name&#39;. Example: github:new-script-format. 
     * @param base Filter pulls by base branch name. Example - gh-pages.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsGet (owner: string, repo: string, state?: 'open' | 'closed', head?: string, base?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Pulls;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsGet.');
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (head !== undefined) {
            localVarQueryParameters['head'] = ObjectSerializer.serialize(head, "string");
        }

        if (base !== undefined) {
            localVarQueryParameters['base'] = ObjectSerializer.serialize(base, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Pulls;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pulls");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List comments on a pull request.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberCommentsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullsComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberCommentsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberCommentsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberCommentsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullsComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullsComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a comment.   #TODO Alternative input ( http://developer.github.com/v3/pulls/comments/ )   description: |     Alternative Input.     Instead of passing commit_id, path, and position you can reply to an     existing Pull Request Comment like this:          body            Required string         in_reply_to            Required number - Comment id to reply to. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberCommentsPost (owner: string, repo: string, number: number, body: PullsCommentPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullsComment;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/comments'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberCommentsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberCommentsPost.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberCommentsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPullsNumberCommentsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PullsCommentPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullsComment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullsComment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List commits on a pull request.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberCommitsGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Commits;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/commits'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberCommitsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberCommitsGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberCommitsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Commits;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Commits");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List pull requests files.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberFilesGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Pulls;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/files'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberFilesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberFilesGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberFilesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Pulls;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pulls");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single pull request.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PullRequest;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PullRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PullRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get if a pull request has been merged.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberMergeGet (owner: string, repo: string, number: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/merge'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberMergeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberMergeGet.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberMergeGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Merge a pull request (Merge Button's)
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberMergePut (owner: string, repo: string, number: number, body: MergePullBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Merge;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}/merge'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberMergePut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberMergePut.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberMergePut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPullsNumberMergePut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MergePullBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Merge;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Merge");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a pull request.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param number Id of pull.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsNumberPatch (owner: string, repo: string, number: number, body: PullUpdate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repo;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls/{number}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'number' + '}', encodeURIComponent(String(number)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsNumberPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsNumberPatch.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling reposOwnerRepoPullsNumberPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPullsNumberPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PullUpdate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repo;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repo");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a pull request.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoPullsPost (owner: string, repo: string, body: PullsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Pulls;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/pulls'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoPullsPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoPullsPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoPullsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PullsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Pulls;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pulls");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the README. This method returns the preferred README for a repository. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref The String name of the Commit/Branch/Tag. Defaults to master.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReadmeGet (owner: string, repo: string, ref?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ContentsPath;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/readme'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReadmeGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReadmeGet.');
        }

        if (ref !== undefined) {
            localVarQueryParameters['ref'] = ObjectSerializer.serialize(ref, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ContentsPath;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ContentsPath");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a release asset
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesAssetsIdDelete (owner: string, repo: string, id: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/assets/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesAssetsIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesAssetsIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesAssetsIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single release asset
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesAssetsIdGet (owner: string, repo: string, id: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Asset;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/assets/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesAssetsIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesAssetsIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesAssetsIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Asset;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Asset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit a release asset Users with push access to the repository can edit a release asset. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesAssetsIdPatch (owner: string, repo: string, id: string, body: AssetPatch, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Asset;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/assets/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesAssetsIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesAssetsIdPatch.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesAssetsIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoReleasesAssetsIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "AssetPatch")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Asset;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Asset");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with push access to the repository will receive all releases (i.e., published releases and draft releases). Users with pull access will receive published releases only
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Releases;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Releases;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Releases");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List assets for a release
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesIdAssetsGet (owner: string, repo: string, id: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Assets;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}/assets'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesIdAssetsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesIdAssetsGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesIdAssetsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Assets;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Assets");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with push access to the repository can delete a release.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesIdDelete (owner: string, repo: string, id: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesIdDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesIdDelete.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single release
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesIdGet (owner: string, repo: string, id: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesIdGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesIdGet.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users with push access to the repository can edit a release
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param id 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesIdPatch (owner: string, repo: string, id: string, body: ReleaseCreate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases/{id}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesIdPatch.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesIdPatch.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling reposOwnerRepoReleasesIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoReleasesIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReleaseCreate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a release Users with push access to the repository can create a release. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoReleasesPost (owner: string, repo: string, body: ReleaseCreate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Release;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/releases'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoReleasesPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoReleasesPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoReleasesPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ReleaseCreate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Release;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Release");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Stargazers.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStargazersGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stargazers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStargazersGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStargazersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the number of additions and deletions per week. Returns a weekly aggregate of the number of additions and deletions pushed to a repository. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatsCodeFrequencyGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CodeFrequencyStats;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stats/code_frequency'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatsCodeFrequencyGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatsCodeFrequencyGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CodeFrequencyStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CodeFrequencyStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the last year of commit activity data. Returns the last year of commit activity grouped by week. The days array is a group of commits per day, starting on Sunday. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatsCommitActivityGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CommitActivityStats;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stats/commit_activity'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatsCommitActivityGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatsCommitActivityGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CommitActivityStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CommitActivityStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get contributors list with additions, deletions, and commit counts.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatsContributorsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ContributorsStats;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stats/contributors'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatsContributorsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatsContributorsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ContributorsStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ContributorsStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the weekly commit count for the repo owner and everyone else.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatsParticipationGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ParticipationStats;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stats/participation'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatsParticipationGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatsParticipationGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ParticipationStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ParticipationStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the number of commits per hour in each day. Each array contains the day number, hour number, and number of commits 0-6 Sunday - Saturday 0-23 Hour of day Number of commits  For example, [2, 14, 25] indicates that there were 25 total commits, during the 2.00pm hour on Tuesdays. All times are based on the time zone of individual commits. 
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatsPunchCardGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CodeFrequencyStats;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/stats/punch_card'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatsPunchCardGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatsPunchCardGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CodeFrequencyStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CodeFrequencyStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Statuses for a specific Ref.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatusesRefGet (owner: string, repo: string, ref: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Ref;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/statuses/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatusesRefGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatusesRefGet.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoStatusesRefGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Ref;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Ref");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Status.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name. 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoStatusesRefPost (owner: string, repo: string, ref: string, body: HeadBranch, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Ref;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/statuses/{ref}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)))
            .replace('{' + 'ref' + '}', encodeURIComponent(String(ref)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoStatusesRefPost.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoStatusesRefPost.');
        }

        // verify required parameter 'ref' is not null or undefined
        if (ref === null || ref === undefined) {
            throw new Error('Required parameter ref was null or undefined when calling reposOwnerRepoStatusesRefPost.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoStatusesRefPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "HeadBranch")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Ref;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Ref");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List watchers.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoSubscribersGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscribers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoSubscribersGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoSubscribersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Repository Subscription.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoSubscriptionDelete (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoSubscriptionDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoSubscriptionDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Repository Subscription.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoSubscriptionGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoSubscriptionGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoSubscriptionGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Set a Repository Subscription
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoSubscriptionPut (owner: string, repo: string, body: SubscriptionBody, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/subscription'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoSubscriptionPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoSubscriptionPut.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling reposOwnerRepoSubscriptionPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "SubscriptionBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Subscription");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of tags.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoTagsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Tags;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/tags'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoTagsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoTagsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Tags;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Tags");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of teams
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoTeamsGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Teams;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/teams'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoTeamsGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoTeamsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Teams;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Teams");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List Stargazers. New implementation.
     * @param owner Name of repository owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public reposOwnerRepoWatchersGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/repos/{owner}/{repo}/watchers'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling reposOwnerRepoWatchersGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling reposOwnerRepoWatchersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public repositories. This provides a dump of every public repository, in the order that they were created. Note: Pagination is powered exclusively by the since parameter. is the Link header to get the URL for the next page of repositories. 
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public repositoriesGet (since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/repositories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search code.
     * @param q The search terms. This can be any combination of the supported code search parameters: &#39;Search In&#39; Qualifies which fields are searched. With this qualifier you can restrict the search to just the file contents, the file path, or both. &#39;Languages&#39; Searches code based on the language it&#39;s written in. &#39;Forks&#39; Filters repositories based on the number of forks, and/or whether code from forked repositories should be included in the results at all. &#39;Size&#39; Finds files that match a certain size (in bytes). &#39;Path&#39; Specifies the path that the resulting file must be at. &#39;Extension&#39; Matches files with a certain extension. &#39;Users&#39; or &#39;Repositories&#39; Limits searches to a specific user or repository. 
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param sort Can only be &#39;indexed&#39;, which indicates how recently a file has been indexed by the GitHub search infrastructure. If not provided, results are sorted by best match. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public searchCodeGet (q: string, order?: 'desc' | 'asc', sort?: 'indexed', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchCode;  }> {
        const localVarPath = this.basePath + '/search/code';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchCodeGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'indexed'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchCode;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchCode");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Find issues by state and keyword. (This method returns up to 100 results per page.)
     * @param q The q search term can also contain any combination of the supported issue search qualifiers:
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param sort The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public searchIssuesGet (q: string, order?: 'desc' | 'asc', sort?: 'updated' | 'created' | 'comments', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchIssues;  }> {
        const localVarPath = this.basePath + '/search/issues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchIssuesGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'updated' | 'created' | 'comments'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchIssues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchIssues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search repositories.
     * @param q The search terms. This can be any combination of the supported repository search parameters: &#39;Search In&#39; Qualifies which fields are searched. With this qualifier you can restrict the search to just the repository name, description, readme, or any combination of these. &#39;Size&#39; Finds repositories that match a certain size (in kilobytes). &#39;Forks&#39; Filters repositories based on the number of forks, and/or whether forked repositories should be included in the results at all. &#39;Created&#39; and &#39;Last Updated&#39; Filters repositories based on times of creation, or when they were last updated. &#39;Users or Repositories&#39; Limits searches to a specific user or repository. &#39;Languages&#39; Searches repositories based on the language they are written in. &#39;Stars&#39; Searches repositories based on the number of stars. 
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param sort If not provided, results are sorted by best match.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public searchRepositoriesGet (q: string, order?: 'desc' | 'asc', sort?: 'stars' | 'forks' | 'updated', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchRepositories;  }> {
        const localVarPath = this.basePath + '/search/repositories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchRepositoriesGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'stars' | 'forks' | 'updated'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchRepositories;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchRepositories");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search users.
     * @param q The search terms. This can be any combination of the supported user search parameters: &#39;Search In&#39; Qualifies which fields are searched. With this qualifier you can restrict the search to just the username, public email, full name, location, or any combination of these. &#39;Repository count&#39; Filters users based on the number of repositories they have. &#39;Location&#39; Filter users by the location indicated in their profile. &#39;Language&#39; Search for users that have repositories that match a certain language. &#39;Created&#39; Filter users based on when they joined. &#39;Followers&#39; Filter users based on the number of followers they have. 
     * @param order The sort field. if sort param is provided. Can be either asc or desc.
     * @param sort If not provided, results are sorted by best match.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public searchUsersGet (q: string, order?: 'desc' | 'asc', sort?: 'followers' | 'repositories' | 'joined', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SearchUsers;  }> {
        const localVarPath = this.basePath + '/search/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchUsersGet.');
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "'desc' | 'asc'");
        }

        if (q !== undefined) {
            localVarQueryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'followers' | 'repositories' | 'joined'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SearchUsers;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SearchUsers");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete team. In order to delete a team, the authenticated user must be an owner of the org that the team is associated with. 
     * @param teamId Id of team.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdDelete (teamId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get team.
     * @param teamId Id of team.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdGet (teamId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List team members. In order to list members in a team, the authenticated user must be a member of the team. 
     * @param teamId Id of team.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembersGet (teamId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/members'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The \"Remove team member\" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Remove team membership API instead. It allows you to remove both active and pending memberships.  Remove team member. In order to remove a user from a team, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. NOTE This does not delete the user, it just remove them from the team. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembersUsernameDelete (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/members/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembersUsernameDelete.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembersUsernameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The \"Get team member\" API is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Get team membership API instead. It allows you to get both active and pending memberships.  Get team member. In order to get if a user is a member of a team, the authenticated user mus be a member of the team. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembersUsernameGet (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/members/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembersUsernameGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembersUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The API (described below) is deprecated and is scheduled for removal in the next major version of the API. We recommend using the Add team membership API instead. It allows you to invite new organization members to your teams.  Add team member. In order to add a user to a team, the authenticated user must have 'admin' permissions to the team or be an owner of the org that the team is associated with. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembersUsernamePut (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/members/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembersUsernamePut.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembersUsernamePut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Remove team membership. In order to remove a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with. NOTE: This does not delete the user, it just removes their membership from the team. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembershipsUsernameDelete (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/memberships/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembershipsUsernameDelete.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembershipsUsernameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get team membership. In order to get a user's membership with a team, the authenticated user must be a member of the team or an owner of the team's organization. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembershipsUsernameGet (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TeamMembership;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/memberships/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembershipsUsernameGet.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembershipsUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TeamMembership;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamMembership");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add team membership. In order to add a membership between a user and a team, the authenticated user must have 'admin' permissions to the team or be an owner of the organization that the team is associated with.  If the user is already a part of the team's organization (meaning they're on at least one other team in the organization), this endpoint will add the user to the team.  If the user is completely unaffiliated with the team's organization (meaning they're on none of the organization's teams), this endpoint will send an invitation to the user via email. This newly-created membership will be in the 'pending' state until the user accepts the invitation, at which point the membership will transition to the 'active' state and the user will be added as a member of the team. 
     * @param teamId Id of team.
     * @param username Name of a member.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdMembershipsUsernamePut (teamId: number, username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TeamMembership;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/memberships/{username}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdMembershipsUsernamePut.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling teamsTeamIdMembershipsUsernamePut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TeamMembership;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamMembership");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Edit team. In order to edit a team, the authenticated user must be an owner of the org that the team is associated with. 
     * @param teamId Id of team.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdPatch (teamId: number, body: EditTeam, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Team;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdPatch.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling teamsTeamIdPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EditTeam")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Team;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Team");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List team repos
     * @param teamId Id of team.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdReposGet (teamId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TeamRepos;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/repos'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdReposGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TeamRepos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamRepos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * In order to remove a repository from a team, the authenticated user must be an owner of the org that the team is associated with. NOTE: This does not delete the repository, it just removes it from the team.
     * @param teamId Id of team.
     * @param owner Name of a repository owner.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdReposOwnerRepoDelete (teamId: number, owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/repos/{owner}/{repo}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdReposOwnerRepoDelete.');
        }

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling teamsTeamIdReposOwnerRepoDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling teamsTeamIdReposOwnerRepoDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if a team manages a repository
     * @param teamId Id of team.
     * @param owner Name of a repository owner.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdReposOwnerRepoGet (teamId: number, owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/repos/{owner}/{repo}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdReposOwnerRepoGet.');
        }

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling teamsTeamIdReposOwnerRepoGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling teamsTeamIdReposOwnerRepoGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * In order to add a repository to a team, the authenticated user must be an owner of the org that the team is associated with. Also, the repository must be owned by the organization, or a direct fork of a repository owned by the organization.
     * @param teamId Id of team.
     * @param owner Name of a organization.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public teamsTeamIdReposOwnerRepoPut (teamId: number, owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/teams/{teamId}/repos/{owner}/{repo}'
            .replace('{' + 'teamId' + '}', encodeURIComponent(String(teamId)))
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'teamId' is not null or undefined
        if (teamId === null || teamId === undefined) {
            throw new Error('Required parameter teamId was null or undefined when calling teamsTeamIdReposOwnerRepoPut.');
        }

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling teamsTeamIdReposOwnerRepoPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling teamsTeamIdReposOwnerRepoPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete email address(es). You can include a single email address or an array of addresses. 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userEmailsDelete (body: UserEmails, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userEmailsDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserEmails")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List email addresses for a user. In the final version of the API, this method will return an array of hashes with extended information for each email address indicating if the address has been verified and if it's primary email address for GitHub. Until API v3 is finalized, use the application/vnd.github.v3 media type to get other response format. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userEmailsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserEmails;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserEmails;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserEmails");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add email address(es). You can post a single email address or an array of addresses. 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userEmailsPost (body: EmailsPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/emails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userEmailsPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "EmailsPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List the authenticated user's followers
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userFollowersGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/user/followers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List who the authenticated user is following.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userFollowingGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/user/following';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unfollow a user. Unfollowing a user requires the user to be logged in and authenticated with basic auth or OAuth with the user:follow scope. 
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userFollowingUsernameDelete (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userFollowingUsernameDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if you are following a user.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userFollowingUsernameGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userFollowingUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Follow a user. Following a user requires the user to be logged in and authenticated with basic auth or OAuth with the user:follow scope. 
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userFollowingUsernamePut (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/following/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling userFollowingUsernamePut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the authenticated user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List issues. List all issues across owned and member repositories for the authenticated user. 
     * @param filter Issues assigned to you / created by you / mentioning you / you&#39;re subscribed to updates for / All issues the authenticated user can see 
     * @param state 
     * @param labels String list of comma separated Label names. Example - bug,ui,@high.
     * @param sort 
     * @param direction 
     * @param since Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Only issues updated at or after this time are returned. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userIssuesGet (filter: 'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all', state: 'open' | 'closed', labels: string, sort: 'created' | 'updated' | 'comments', direction: 'asc' | 'desc', since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Issues;  }> {
        const localVarPath = this.basePath + '/user/issues';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'filter' is not null or undefined
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling userIssuesGet.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling userIssuesGet.');
        }

        // verify required parameter 'labels' is not null or undefined
        if (labels === null || labels === undefined) {
            throw new Error('Required parameter labels was null or undefined when calling userIssuesGet.');
        }

        // verify required parameter 'sort' is not null or undefined
        if (sort === null || sort === undefined) {
            throw new Error('Required parameter sort was null or undefined when calling userIssuesGet.');
        }

        // verify required parameter 'direction' is not null or undefined
        if (direction === null || direction === undefined) {
            throw new Error('Required parameter direction was null or undefined when calling userIssuesGet.');
        }

        if (filter !== undefined) {
            localVarQueryParameters['filter'] = ObjectSerializer.serialize(filter, "'assigned' | 'created' | 'mentioned' | 'subscribed' | 'all'");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "'open' | 'closed'");
        }

        if (labels !== undefined) {
            localVarQueryParameters['labels'] = ObjectSerializer.serialize(labels, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated' | 'comments'");
        }

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "'asc' | 'desc'");
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Issues;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Issues");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List your public keys. Lists the current user's keys. Management of public keys via the API requires that you are authenticated through basic auth, or OAuth with the 'user', 'write:public_key' scopes. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userKeysGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/user/keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a public key. Removes a public key. Requires that you are authenticated via Basic Auth or via OAuth with at least admin:public_key scope.
     * @param keyId ID of key.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userKeysKeyIdDelete (keyId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/keys/{keyId}'
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling userKeysKeyIdDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single public key.
     * @param keyId ID of key.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userKeysKeyIdGet (keyId: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }> {
        const localVarPath = this.basePath + '/user/keys/{keyId}'
            .replace('{' + 'keyId' + '}', encodeURIComponent(String(keyId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'keyId' is not null or undefined
        if (keyId === null || keyId === undefined) {
            throw new Error('Required parameter keyId was null or undefined when calling userKeysKeyIdGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserKeysKeyId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a public key.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userKeysPost (body: UserKeysPost, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }> {
        const localVarPath = this.basePath + '/user/keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userKeysPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserKeysPost")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserKeysKeyId;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserKeysKeyId");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public and private organizations for the authenticated user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userOrgsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/user/orgs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the authenticated user.
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userPatch (body: UserUpdate, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userPatch.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UserUpdate")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories for the authenticated user. Note that this does not include repositories owned by organizations which the user can access. You can lis user organizations and list organization repositories separately. 
     * @param type 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public async userReposGet (type?: 'all' | 'public' | 'private' | 'forks' | 'sources' | 'member', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'all' | 'public' | 'private' | 'forks' | 'sources' | 'member'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                  body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new repository for the authenticated user. OAuth users must supply repo scope. 
     * @param body 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userReposPost (body: PostRepo, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/user/repos';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling userReposPost.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "PostRepo")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories being starred by the authenticated user.
     * @param direction Ignored without &#39;sort&#39; parameter.
     * @param sort 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userStarredGet (direction?: string, sort?: 'created' | 'updated', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/user/starred';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (direction !== undefined) {
            localVarQueryParameters['direction'] = ObjectSerializer.serialize(direction, "string");
        }

        if (sort !== undefined) {
            localVarQueryParameters['sort'] = ObjectSerializer.serialize(sort, "'created' | 'updated'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Unstar a repository
     * @param owner Name of a repository owner.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userStarredOwnerRepoDelete (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userStarredOwnerRepoDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userStarredOwnerRepoDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if you are starring a repository.
     * @param owner Name of a repository owner.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userStarredOwnerRepoGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userStarredOwnerRepoGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userStarredOwnerRepoGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Star a repository.
     * @param owner Name of a repository owner.
     * @param repo Name of a repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userStarredOwnerRepoPut (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/starred/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userStarredOwnerRepoPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userStarredOwnerRepoPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories being watched by the authenticated user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userSubscriptionsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/user/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Stop watching a repository
     * @param owner Name of the owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userSubscriptionsOwnerRepoDelete (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/subscriptions/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userSubscriptionsOwnerRepoDelete.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userSubscriptionsOwnerRepoDelete.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if you are watching a repository.
     * @param owner Name of the owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userSubscriptionsOwnerRepoGet (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/subscriptions/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userSubscriptionsOwnerRepoGet.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userSubscriptionsOwnerRepoGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Watch a repository.
     * @param owner Name of the owner.
     * @param repo Name of repository.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userSubscriptionsOwnerRepoPut (owner: string, repo: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/user/subscriptions/{owner}/{repo}'
            .replace('{' + 'owner' + '}', encodeURIComponent(String(owner)))
            .replace('{' + 'repo' + '}', encodeURIComponent(String(repo)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'owner' is not null or undefined
        if (owner === null || owner === undefined) {
            throw new Error('Required parameter owner was null or undefined when calling userSubscriptionsOwnerRepoPut.');
        }

        // verify required parameter 'repo' is not null or undefined
        if (repo === null || repo === undefined) {
            throw new Error('Required parameter repo was null or undefined when calling userSubscriptionsOwnerRepoPut.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all of the teams across all of the organizations to which the authenticated user belongs. This method requires user or repo scope when authenticating via OAuth.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public userTeamsGet (accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TeamsList;  }> {
        const localVarPath = this.basePath + '/user/teams';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TeamsList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TeamsList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get all users. This provides a dump of every user, in the order that they signed up for GitHub. Note: Pagination is powered exclusively by the since parameter. Use the Link header to get the URL for the next page of users. 
     * @param since The integer ID of the last user that you&#39;ve seen.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersGet (since?: number, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "number");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * If you are authenticated as the given user, you will see your private events. Otherwise, you'll only see public events.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameEventsGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/events'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This is the user's organization dashboard. You must be authenticated as the user to view this.
     * @param username Name of user.
     * @param org 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameEventsOrgsOrgGet (username: string, org: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/events/orgs/{org}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'org' + '}', encodeURIComponent(String(org)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameEventsOrgsOrgGet.');
        }

        // verify required parameter 'org' is not null or undefined
        if (org === null || org === undefined) {
            throw new Error('Required parameter org was null or undefined when calling usersUsernameEventsOrgsOrgGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List a user's followers
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameFollowersGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Users;  }> {
        const localVarPath = this.basePath + '/users/{username}/followers'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameFollowersGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Users;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Users");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Check if one user follows another.
     * @param username Name of user.
     * @param targetUser Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameFollowingTargetUserGet (username: string, targetUser: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/following/{targetUser}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'targetUser' + '}', encodeURIComponent(String(targetUser)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameFollowingTargetUserGet.');
        }

        // verify required parameter 'targetUser' is not null or undefined
        if (targetUser === null || targetUser === undefined) {
            throw new Error('Required parameter targetUser was null or undefined when calling usersUsernameFollowingTargetUserGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a single user.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public async usersUsernameGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: User;  }> {
        const localVarPath = this.basePath + '/users/{username}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;
        
        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return await new Promise<{ response: http.IncomingMessage; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List a users gists.
     * @param username Name of user.
     * @param since The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. Example: \&quot;2012-10-09T23:39:01Z\&quot;. 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameGistsGet (username: string, since?: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gists;  }> {
        const localVarPath = this.basePath + '/users/{username}/gists'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameGistsGet.');
        }

        if (since !== undefined) {
            localVarQueryParameters['since'] = ObjectSerializer.serialize(since, "string");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gists;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gists");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public keys for a user. Lists the verified public keys for a user. This is accessible by anyone. 
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameKeysGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/users/{username}/keys'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameKeysGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List all public organizations for a user.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameOrgsGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Gitignore;  }> {
        const localVarPath = this.basePath + '/users/{username}/orgs'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameOrgsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Gitignore;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Gitignore");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * These are events that you'll only see public events.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameReceivedEventsGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/received_events'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameReceivedEventsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public events that a user has received
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameReceivedEventsPublicGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/received_events/public'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameReceivedEventsPublicGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List public repositories for the specified user.
     * @param username Name of user.
     * @param type 
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameReposGet (username: string, type?: 'all' | 'public' | 'private' | 'forks' | 'sources' | 'member', accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Repos;  }> {
        const localVarPath = this.basePath + '/users/{username}/repos'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameReposGet.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'all' | 'public' | 'private' | 'forks' | 'sources' | 'member'");
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Repos;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Repos");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories being starred by a user.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameStarredGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/starred'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameStarredGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List repositories being watched by a user.
     * @param username Name of user.
     * @param accept Is used to set specified media type.
     * @param {*} [options] Override http request options.
     */
    public usersUsernameSubscriptionsGet (username: string, accept?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/users/{username}/subscriptions'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling usersUsernameSubscriptionsGet.');
        }

        localVarHeaderParams['Accept'] = ObjectSerializer.serialize(accept, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error: any, response: any, body: any) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
